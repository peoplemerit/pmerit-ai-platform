<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
  <title>Classroom | PMERIT Learner Portal</title>
  <meta name="description" content="Interactive classroom with AI Tutor and Virtual Human">

  <!-- Google Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">

  <!-- Font Awesome -->
  <link
    rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css"
    integrity="sha512-SnH5WK+bZxgPHs44uWIX+LLJAJ9/2PkPKZ5QiAj6Ta86w+fsb2TkcmfRyVX3pBnMFcV7oQPJkl9QevSCWr3W6A=="
    crossorigin="anonymous"
    referrerpolicy="no-referrer">

  <!-- CLASSROOM APP SHELL CSS (v1.0 - Session 47) -->
  <link rel="stylesheet" href="../assets/css/classroom.css">

  <!-- Legacy CSS for components not yet migrated -->
  <link rel="stylesheet" href="../assets/css/avatar.css">
  <link rel="stylesheet" href="../assets/css/proctor-mode.css">

  <!-- Avatar Settings Panel Styles -->
  <style>
    /* Chat Header Actions */
    .chat-header__actions {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    /* Voice Settings Button in Chat Header - Always Visible */
    .chat-header__settings-btn {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 36px;
      height: 36px;
      border-radius: 8px;
      background: linear-gradient(135deg, #6366f1, #8b5cf6);
      border: none;
      color: white;
      font-size: 16px;
      cursor: pointer;
      transition: all 0.2s ease;
      box-shadow: 0 2px 8px rgba(99, 102, 241, 0.3);
    }
    .chat-header__settings-btn:hover {
      transform: scale(1.05);
      box-shadow: 0 4px 12px rgba(99, 102, 241, 0.4);
    }
    .chat-header__settings-btn:active {
      transform: scale(0.95);
    }

    /* Settings Button on Avatar (secondary, less prominent) */
    .avatar-settings-btn {
      position: absolute;
      top: 8px;
      right: 8px;
      width: 32px;
      height: 32px;
      border: none;
      border-radius: 50%;
      background: rgba(0, 0, 0, 0.5);
      color: #fff;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
      z-index: 10;
    }
    .avatar-settings-btn:hover {
      background: rgba(0, 0, 0, 0.7);
      transform: rotate(90deg);
    }

    /* Settings Modal */
    .avatar-settings-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.6);
      z-index: 1000;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .avatar-settings-modal__content {
      background: var(--color-surface, #1e1e2e);
      border-radius: 12px;
      width: 90%;
      max-width: 400px;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.4);
      overflow: hidden;
    }
    .avatar-settings-modal__header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 16px 20px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }
    .avatar-settings-modal__header h3 {
      margin: 0;
      font-size: 1.1rem;
      color: var(--color-text, #fff);
    }
    .avatar-settings-modal__close {
      background: none;
      border: none;
      color: var(--color-text-muted, #888);
      cursor: pointer;
      font-size: 1.2rem;
      padding: 4px 8px;
    }
    .avatar-settings-modal__close:hover {
      color: var(--color-text, #fff);
    }
    .avatar-settings-modal__body {
      padding: 20px;
    }
    .setting-group {
      margin-bottom: 20px;
    }
    .setting-group:last-child {
      margin-bottom: 0;
    }
    .setting-group label {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 0.9rem;
      font-weight: 500;
      color: var(--color-text, #fff);
      margin-bottom: 8px;
    }
    .setting-group label i {
      color: var(--color-primary, #6C63FF);
    }
    .setting-group small {
      display: block;
      color: var(--color-text-muted, #888);
      font-size: 0.75rem;
      margin-top: 4px;
    }
    .setting-slider-row {
      display: flex;
      align-items: center;
      gap: 12px;
    }
    .setting-slider-row input[type="range"] {
      flex: 1;
      height: 6px;
      border-radius: 3px;
      background: rgba(255, 255, 255, 0.1);
      appearance: none;
      cursor: pointer;
    }
    .setting-slider-row input[type="range"]::-webkit-slider-thumb {
      appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: var(--color-primary, #6C63FF);
      cursor: pointer;
    }
    .setting-slider-row span {
      min-width: 50px;
      text-align: right;
      font-size: 0.9rem;
      color: var(--color-text, #fff);
      font-weight: 500;
    }
    .setting-group select {
      width: 100%;
      padding: 10px 12px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      background: rgba(0, 0, 0, 0.3);
      color: var(--color-text, #fff);
      font-size: 0.9rem;
      cursor: pointer;
    }
    .setting-group select:focus {
      outline: none;
      border-color: var(--color-primary, #6C63FF);
    }
    .setting-group input[type="checkbox"] {
      width: 18px;
      height: 18px;
      margin-right: 8px;
      cursor: pointer;
    }
    .avatar-settings-modal__footer {
      padding: 16px 20px;
      border-top: 1px solid rgba(255, 255, 255, 0.1);
    }
    .avatar-settings-modal__footer .btn {
      width: 100%;
      padding: 12px;
      border: none;
      border-radius: 8px;
      background: var(--color-primary, #6C63FF);
      color: #fff;
      font-size: 0.9rem;
      font-weight: 600;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      transition: background 0.2s ease;
    }
    .avatar-settings-modal__footer .btn:hover {
      background: var(--color-primary-hover, #5a52e0);
    }

    /* Voice selection row with preview button */
    .setting-voice-row {
      display: flex;
      gap: 8px;
      align-items: stretch;
    }
    .setting-voice-row select {
      flex: 1;
    }
    .btn-preview {
      width: 42px;
      height: 42px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      background: rgba(0, 0, 0, 0.3);
      color: var(--color-text, #fff);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
    }
    .btn-preview:hover {
      background: var(--color-primary, #6C63FF);
      border-color: var(--color-primary, #6C63FF);
    }
    .btn-preview:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .btn-preview.playing i {
      animation: pulse 1s infinite;
    }
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    /* Premium upsell modal */
    .premium-upsell-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      z-index: 1100;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .premium-upsell-modal__content {
      background: linear-gradient(135deg, #1e1e2e 0%, #2d2d44 100%);
      border-radius: 16px;
      width: 90%;
      max-width: 420px;
      text-align: center;
      padding: 32px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
      border: 1px solid rgba(108, 99, 255, 0.3);
    }
    .premium-upsell-modal__icon {
      font-size: 48px;
      margin-bottom: 16px;
    }
    .premium-upsell-modal__title {
      font-size: 1.5rem;
      font-weight: 700;
      color: #fff;
      margin-bottom: 12px;
    }
    .premium-upsell-modal__message {
      color: var(--color-text-muted, #aaa);
      margin-bottom: 20px;
      line-height: 1.6;
    }
    .premium-upsell-modal__features {
      text-align: left;
      margin-bottom: 24px;
      padding: 16px;
      background: rgba(0, 0, 0, 0.2);
      border-radius: 8px;
    }
    .premium-upsell-modal__features li {
      color: #fff;
      margin-bottom: 8px;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .premium-upsell-modal__features li i {
      color: #FFD700;
    }
    .premium-upsell-modal__buttons {
      display: flex;
      gap: 12px;
      flex-direction: column;
    }
    .premium-upsell-modal__buttons .btn-upgrade {
      padding: 14px 24px;
      background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
      border: none;
      border-radius: 8px;
      color: #000;
      font-weight: 700;
      font-size: 1rem;
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }
    .premium-upsell-modal__buttons .btn-upgrade:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 20px rgba(255, 215, 0, 0.4);
    }
    .premium-upsell-modal__buttons .btn-cancel {
      padding: 10px;
      background: transparent;
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 8px;
      color: var(--color-text-muted, #888);
      cursor: pointer;
    }
    .premium-upsell-modal__buttons .btn-cancel:hover {
      background: rgba(255, 255, 255, 0.05);
    }
  </style>

  <!-- Three.js r137 (last version with global THREE.GLTFLoader in examples/js/) -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.137.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.137.0/examples/js/loaders/GLTFLoader.js"></script>
  <!-- Meshopt decoder for compressed GLB models -->
  <script src="https://cdn.jsdelivr.net/npm/meshoptimizer@0.20.0/meshopt_decoder.js"></script>
  <script>
    // Configure GLTFLoader with meshopt decoder after both are loaded
    (async function() {
      if (typeof MeshoptDecoder !== 'undefined') {
        await MeshoptDecoder.ready;
        window.MeshoptDecoderReady = true;
        console.log('‚úÖ MeshoptDecoder ready');
      }
      // Verify GLTFLoader is available
      if (typeof THREE !== 'undefined' && typeof THREE.GLTFLoader !== 'undefined') {
        console.log('‚úÖ THREE.GLTFLoader available (r137)');
      } else {
        console.error('‚ùå THREE.GLTFLoader not found!');
      }
    })();
  </script>
  
  <!-- Auth protection -->
  <script src="../assets/js/config.js"></script>
  <script src="../assets/js/auth.js"></script>
  <script src="../assets/js/auth-check.js"></script>
  
  <!-- Avatar modules -->
  <script src="../assets/js/avatar/AudioPlayer.js"></script>
  <script src="../assets/js/avatar/LipSyncVisemes.js"></script>
  <script src="../assets/js/avatar/WebGLProvider.js"></script>
  <!--<script src="../assets/js/avatar/AvatarManager.js"></script>-->
  <script src="../assets/js/avatar/AvatarManager.js"></script>
    
    <!-- Virtual Human API (MUST load before controller) -->
    <script src="../assets/js/virtual-human-api.js?v=2"></script>

    <!-- NOTE: virtual-human-controller.js is NOT loaded here because
         classroom.html has its own VH system in #vh-root with GPUStreaming.
         Loading it would create duplicate overlays and toggle conflicts. -->
  
  <!-- TTS module -->
  <script src="../assets/js/tts.js"></script>

  <!-- Classroom Session API -->
  <script src="../assets/js/classroom-session.js"></script>

  <!-- Digital Desk Phase 2-4: Proctor, Vision AI, GPU Streaming, Lip Sync -->
  <script src="../assets/js/proctor-controller.js"></script>
  <script src="../assets/js/vision-ai.js"></script>
  <script src="../assets/js/gpu-streaming.js"></script>
  <script src="../assets/js/lip-sync-controller.js"></script>
</head>
<body class="classroom-body">
  <!-- APP SHELL CONTAINER -->
  <div class="classroom-app">

    <!-- HEADER - Fixed top bar -->
    <header class="classroom-header">
      <div class="classroom-header__brand">
        <a href="../index.html" class="classroom-header__logo" title="Back to Homepage">
          <i class="fas fa-graduation-cap"></i> PMERIT
        </a>
        <span class="classroom-header__title" id="lesson-title">Loading course...</span>
      </div>

      <!-- Proctor Status (Center) -->
      <div class="classroom-header__center">
        <div class="proctor-status off" id="proctor-status">
          <span class="status-dot"></span>
          <span class="status-text">Proctor: Off</span>
        </div>
      </div>

      <nav class="classroom-header__nav">
        <a href="../dashboard.html" class="classroom-header__nav-link">
          <i class="fas fa-home"></i> <span>Dashboard</span>
        </a>
        <a href="../courses.html" class="classroom-header__nav-link">
          <i class="fas fa-book"></i> <span>Courses</span>
        </a>
        <span class="classroom-header__user" id="user-display">
          <i class="fas fa-user"></i> User
        </span>
      </nav>
    </header>

    <!-- MAIN CONTENT - 3 Column Layout -->
    <div class="classroom-main">

      <!-- LEFT PANEL: Tabbed (Outline | Notes | Resources) -->
      <aside class="classroom-panel--left">
        <div class="panel-tabs">
          <button class="panel-tab active" data-tab="outline">
            <i class="fas fa-list"></i> Outline
          </button>
          <button class="panel-tab" data-tab="notes">
            <i class="fas fa-sticky-note"></i> Notes
          </button>
          <button class="panel-tab" data-tab="resources">
            <i class="fas fa-folder-open"></i> Resources
          </button>
        </div>

        <div class="panel-content">
          <!-- Outline Tab -->
          <div class="tab-pane active" id="tab-outline">
            <div id="outline-container">
              <!-- Course modules and lessons rendered here -->
            </div>
          </div>

          <!-- Notes Tab -->
          <div class="tab-pane" id="tab-notes">
            <textarea
              id="notes-text"
              class="notes-textarea"
              placeholder="Write your notes here..."
            ></textarea>
            <button id="save-notes" class="btn btn--secondary" style="width: 100%; margin-top: 12px;">
              <i class="fas fa-save"></i> Save Notes
            </button>
          </div>

          <!-- Resources Tab -->
          <div class="tab-pane" id="tab-resources">
            <input
              type="file"
              id="file-upload"
              accept=".pdf,.doc,.docx,.txt,.png,.jpg,.jpeg"
              multiple
              style="display: none;"
            >
            <button class="btn btn--secondary" style="width: 100%; margin-bottom: 12px;" onclick="document.getElementById('file-upload').click()">
              <i class="fas fa-upload"></i> Upload File
            </button>
            <div id="resources-container" class="resources-list">
              <!-- Uploaded resources appear here -->
            </div>
          </div>
        </div>
      </aside>

      <!-- CENTER PANEL: Content Stage -->
      <main class="classroom-panel--center">
        <!-- Content Header -->
        <div class="content-stage__header">
          <div class="content-stage__lesson-title" id="current-lesson-title">Select a lesson to begin</div>
          <div class="content-stage__actions">
            <button class="btn btn--secondary" id="vh-toggle" title="Toggle Virtual Human">
              <i class="fas fa-robot"></i>
            </button>
            <button class="btn btn--danger" id="end-class">
              <i class="fas fa-door-open"></i> End Class
            </button>
          </div>
        </div>

        <!-- Scrollable Content Viewport -->
        <div class="content-stage__viewport">
          <div class="content-player" id="player-area">
            <!-- Lesson content rendered here -->
            <div style="display: flex; align-items: center; justify-content: center; height: 100%; color: var(--classroom-text-muted);">
              <div style="text-align: center;">
                <i class="fas fa-play-circle" style="font-size: 64px; margin-bottom: 16px; opacity: 0.5;"></i>
                <p>Select a lesson from the outline to begin</p>
              </div>
            </div>
          </div>
        </div>

        <!-- Playback Controls Bar -->
        <div class="playback-controls">
          <button id="prev-lesson-btn" class="playback-btn" disabled>
            <i class="fas fa-step-backward"></i> Previous
          </button>
          <button id="pause-lesson-btn" class="playback-btn">
            <i class="fas fa-pause"></i> Pause
          </button>
          <div class="progress-bar-container">
            <div class="progress-bar-label">
              <span>Progress</span>
              <span id="progress-percent">0%</span>
            </div>
            <div class="progress-bar">
              <div class="progress-bar__fill" id="progress-bar" style="width: 0%;"></div>
            </div>
          </div>
          <button id="bookmark-btn" class="playback-btn">
            <i class="fas fa-bookmark"></i> Bookmark
          </button>
          <button id="next-lesson-btn" class="playback-btn playback-btn--primary" disabled>
            Next <i class="fas fa-step-forward"></i>
          </button>
        </div>
      </main>

      <!-- RIGHT PANEL: AI Tutor Chat -->
      <aside class="classroom-panel--right">
        <!-- CLASSROOM-2B: Docked Avatar -->
        <div class="sidebar-avatar" id="sidebar-avatar">
          <!-- Canvas created dynamically by GPUStreaming -->
          <div class="sidebar-avatar__fallback" id="sidebar-avatar-fallback">
            <i class="fas fa-user-graduate"></i>
          </div>
          <div class="sidebar-avatar__live-badge" id="sidebar-avatar-live" style="display: none;">
            <span class="sidebar-avatar__live-dot"></span>
            <span>LIVE</span>
          </div>
          <div class="sidebar-avatar__captions" id="sidebar-avatar-captions" aria-live="polite"></div>
          <span class="sidebar-avatar__status" id="sidebar-avatar-status">Ready</span>
          <!-- Avatar Settings Button -->
          <button id="avatar-settings-btn" class="avatar-settings-btn" title="AI Tutor Settings">
            <i class="fas fa-cog"></i>
          </button>
        </div>

        <!-- Avatar Settings Modal -->
        <div id="avatar-settings-modal" class="avatar-settings-modal" style="display: none;">
          <div class="avatar-settings-modal__content">
            <div class="avatar-settings-modal__header">
              <h3><i class="fas fa-sliders-h"></i> AI Tutor Settings</h3>
              <button id="avatar-settings-close" class="avatar-settings-modal__close">
                <i class="fas fa-times"></i>
              </button>
            </div>

            <div class="avatar-settings-modal__body">
              <!-- Speech Speed -->
              <div class="setting-group">
                <label for="speech-rate">
                  <i class="fas fa-tachometer-alt"></i> Speech Speed
                </label>
                <div class="setting-slider-row">
                  <input type="range" id="speech-rate" min="0.5" max="1.5" step="0.05" value="0.85">
                  <span id="speech-rate-value">0.85x</span>
                </div>
                <small>Slower speeds are better for learning</small>
              </div>

              <!-- Voice Selection -->
              <div class="setting-group">
                <label for="voice-select">
                  <i class="fas fa-microphone-alt"></i> Voice
                </label>
                <div class="setting-voice-row">
                  <select id="voice-select">
                    <optgroup label="Server Voices">
                      <option value="standard-male">Professor Merit (Male)</option>
                      <option value="standard-female">Dr. Ada (Female)</option>
                      <option value="standard-young">Assistant (Young)</option>
                    </optgroup>
                    <optgroup label="Browser Voices (Natural)">
                      <option value="browser">Browser Voice (Auto-select)</option>
                    </optgroup>
                    <optgroup label="Premium Voices">
                      <option value="primo" data-premium="true">Natural Male</option>
                      <option value="primo-female" data-premium="true">Natural Female</option>
                    </optgroup>
                  </select>
                  <button type="button" id="preview-voice-btn" class="btn-preview" title="Preview Voice">
                    <i class="fas fa-play"></i>
                  </button>
                </div>
                <small id="voice-description">Server-generated voice using Edge TTS</small>
              </div>

              <!-- Avatar Toggle -->
              <div class="setting-group">
                <label>
                  <input type="checkbox" id="avatar-enabled" checked>
                  <i class="fas fa-user"></i> Show Avatar
                </label>
                <small>Disable for faster loading on slow connections</small>
              </div>

              <!-- Audio Captions -->
              <div class="setting-group">
                <label>
                  <input type="checkbox" id="captions-enabled" checked>
                  <i class="fas fa-closed-captioning"></i> Show Captions
                </label>
                <small>Display text while avatar speaks</small>
              </div>
            </div>

            <div class="avatar-settings-modal__footer">
              <button id="avatar-settings-save" class="btn btn--primary">
                <i class="fas fa-check"></i> Save Settings
              </button>
            </div>
          </div>
        </div>

        <!-- Premium Upsell Modal -->
        <div id="premium-upsell-modal" class="premium-upsell-modal" style="display: none;">
          <div class="premium-upsell-modal__content">
            <div class="premium-upsell-modal__icon">‚ú®</div>
            <h3 class="premium-upsell-modal__title">Premium Voice Selected</h3>
            <p class="premium-upsell-modal__message">
              Unlock ultra-natural AI voices that sound like real human tutors.
            </p>
            <ul class="premium-upsell-modal__features">
              <li><i class="fas fa-check"></i> Natural-sounding AI voices</li>
              <li><i class="fas fa-check"></i> Multiple voice personalities</li>
              <li><i class="fas fa-check"></i> Faster audio generation</li>
              <li><i class="fas fa-check"></i> 50+ language support</li>
              <li><i class="fas fa-check"></i> Priority support</li>
            </ul>
            <div class="premium-upsell-modal__buttons">
              <button id="premium-upgrade-btn" class="btn-upgrade">
                <i class="fas fa-crown"></i> Upgrade to Premium
              </button>
              <button id="premium-cancel-btn" class="btn-cancel">
                Maybe Later
              </button>
            </div>
          </div>
        </div>

        <div class="chat-header">
          <span class="chat-header__title">
            <i class="fas fa-comments"></i> Chat
          </span>
          <div class="chat-header__actions">
            <!-- Voice/TTS Settings Button - Always Visible -->
            <button id="chat-voice-settings-btn" class="chat-header__settings-btn" title="Voice & TTS Settings">
              <i class="fas fa-volume-up"></i>
            </button>
            <div class="chat-stats">
              <span class="chat-stat" title="Hand Raises">
                <i class="fas fa-hand-paper"></i>
                <span id="stat-hand-raises">0</span>
              </span>
              <span class="chat-stat" title="Questions">
                <i class="fas fa-question-circle"></i>
                <span id="stat-questions">0</span>
              </span>
            </div>
          </div>
        </div>

        <button id="raise-hand-btn" class="raise-hand-btn">
          <i class="fas fa-hand-paper"></i> Raise Hand
        </button>

        <div class="chat-messages" id="chat-messages">
          <!-- Chat messages appear here -->
        </div>

        <form class="chat-form" id="chat-form">
          <div class="chat-input-wrapper">
            <button type="button" class="chat-input-icon" id="chat-attach-btn" title="Attach file">
              <i class="fas fa-paperclip"></i>
            </button>
            <input
              type="text"
              id="chat-input"
              class="chat-input"
              placeholder="Ask your AI tutor..."
              required
            >
            <button type="button" class="chat-input-icon" id="chat-voice-btn" title="Voice input">
              <i class="fas fa-microphone"></i>
            </button>
            <button type="submit" class="chat-submit-btn" title="Send">
              <i class="fas fa-arrow-up"></i>
            </button>
          </div>
        </form>
      </aside>

    </div><!-- /.classroom-main -->

    <!-- Mobile Menu Toggle Button -->
    <button class="mobile-menu-toggle" id="mobile-menu-toggle" aria-label="Toggle course outline">
      <i class="fas fa-list"></i>
    </button>

    <!-- Mobile Overlay -->
    <div class="mobile-overlay" id="mobile-overlay"></div>

  </div><!-- /.classroom-app -->

  <!-- AVATAR PIP (Picture-in-Picture Widget) -->
  <div id="vh-root" class="avatar-pip hidden" aria-hidden="true">
    <div class="avatar-pip__header" id="widget-drag-handle">
      <span class="avatar-pip__title"><i class="fas fa-robot"></i> AI Tutor</span>
      <div class="avatar-pip__controls">
        <button class="avatar-pip__btn" id="widget-minimize" title="Minimize">
          <i class="fas fa-minus"></i>
        </button>
        <button class="avatar-pip__btn" id="widget-close" title="Hide">
          <i class="fas fa-times"></i>
        </button>
      </div>
    </div>
    <div class="avatar-pip__stage" id="avatar-frame">
      <div class="avatar-pip__live-badge" id="avatar-live-badge" style="display: none;">
        <span class="avatar-pip__live-dot"></span>
        <span>LIVE</span>
      </div>
      <canvas class="avatar-pip__canvas" id="vh-canvas"></canvas>
      <div class="avatar-pip__fallback" id="avatar-fallback">
        <i class="fas fa-user-graduate"></i>
      </div>
      <div class="avatar-pip__captions" id="vh-captions" aria-live="polite"></div>
    </div>
    <div class="avatar-pip__footer">
      <span class="avatar-pip__status" id="vh-status-text">Ready</span>
    </div>
    <!-- Mobile drag hint tooltip -->
    <div class="avatar-pip__drag-hint" id="avatar-drag-hint">
      <i class="fas fa-hand-pointer"></i>
      <span>Drag me anywhere!</span>
    </div>
  </div>

  <script>
    (function () {
      'use strict';

      // Parse courseId and lessonId from URL
      const urlParams = new URLSearchParams(window.location.search);
      const courseId = urlParams.get('courseId') || urlParams.get('course_id');
      const lessonId = urlParams.get('lessonId') || urlParams.get('lesson_id');

      // State management
      const state = {
        courseId: courseId,
        lessonId: lessonId,
        courseData: null,
        currentLesson: null,
        lessonNavigation: null,
        modules: [],
        notes: { content: "", timestamp: null },
        resources: [],
        avatarManager: null,
        gpuStreaming: null,
        sessionStart: Date.now(),
        chatMessages: [],
        userHasInteracted: false,  // Track if user has clicked/typed (for autoplay policy)
        welcomeSpoken: false       // Track if welcome has been spoken
      };

      // Expose state for debugging
      window.classroomState = state;

      // DOM elements
      const dom = {
        lessonTitle: document.getElementById('lesson-title'),
        outlineContainer: document.getElementById('outline-container'),
        notesText: document.getElementById('notes-text'),
        saveNotesBtn: document.getElementById('save-notes'),
        resourcesContainer: document.getElementById('resources-container'),
        fileUpload: document.getElementById('file-upload'),
        endClassBtn: document.getElementById('end-class'),
        chatMessages: document.getElementById('chat-messages'),
        chatForm: document.getElementById('chat-form'),
        chatInput: document.getElementById('chat-input'),
        vhToggle: document.getElementById('vh-toggle'),
        vhContainer: document.getElementById('vh-root'),
        userDisplay: document.getElementById('user-display'),
        playerArea: document.getElementById('player-area'),
        // New controls
        raiseHandBtn: document.getElementById('raise-hand-btn'),
        prevLessonBtn: document.getElementById('prev-lesson-btn'),
        nextLessonBtn: document.getElementById('next-lesson-btn'),
        pauseBtn: document.getElementById('pause-lesson-btn'),
        bookmarkBtn: document.getElementById('bookmark-btn'),
        progressBar: document.getElementById('progress-bar'),
        progressPercent: document.getElementById('progress-percent'),
        statHandRaises: document.getElementById('stat-hand-raises'),
        statQuestions: document.getElementById('stat-questions'),
        // Avatar frame elements - CLASSROOM-2B: Now targets sidebar avatar
        avatarFrame: document.getElementById('sidebar-avatar'),
        avatarCanvas: document.getElementById('sidebar-avatar-canvas'),
        avatarLiveBadge: document.getElementById('sidebar-avatar-live'),
        avatarFallback: document.getElementById('sidebar-avatar-fallback'),
        avatarCaptions: document.getElementById('sidebar-avatar-captions'),
        avatarStatus: document.getElementById('sidebar-avatar-status'),
        // Proctor
        proctorStatus: document.getElementById('proctor-status')
      };

      // Initialize
      async function init() {
        console.log('üéì Initializing classroom for course:', courseId);

        // Validate course ID
        if (!courseId) {
          showError('No course specified. Please select a course from your dashboard.');
          return;
        }

        // Set user display
        const user = window.AUTH?.getCurrentUser();
        if (user) {
          const displayName = user.firstName || user.email?.split('@')[0] || 'Student';
          dom.userDisplay.textContent = displayName;
        }

        // Load saved VH preference, defaulting to true (enabled)
        const savedPreference = localStorage.getItem('pmerit_vh_enabled');
        const vhEnabled = savedPreference === 'false' ? false : true;
        updateVHToggle(vhEnabled);

        bindEvents();

        // Start classroom session via API
        try {
          dom.lessonTitle.textContent = 'Starting session...';
          const session = await window.ClassroomSession.startSession(courseId, lessonId);

          if (session.resumed) {
            addChatMessage('ai', `Welcome back! Resuming your session for "${session.course.title}".`);
          } else {
            addChatMessage('ai', `Welcome to "${session.course.title}"! I'm your AI tutor. Feel free to ask questions anytime.`);
          }

          state.courseData = session.course;
          dom.lessonTitle.textContent = session.course.title;

          // Load course modules and lessons
          await loadCourseModules();

        } catch (error) {
          console.error('Failed to start session:', error);
          // Fallback to demo mode
          addChatMessage('ai', 'Hello! I\'m your AI tutor. How can I help you today?');
          await loadCourseDataFallback();
        }

        loadUserNotes();
        renderOutline();

        // Initialize avatar manager
        await initAvatarManager(vhEnabled);

        // Initialize GPU Streaming for tiered avatar (Phase 4)
        state.gpuStreaming = await initGPUStreaming();

        console.log('‚úÖ Classroom initialized');
        console.log('üéÆ Digital Desk modules loaded: ProctorController, VisionAI, GPUStreaming');

        // Set up user interaction listener for autoplay policy
        // Browser requires user interaction before playing audio
        setupUserInteractionListener();
      }

      /**
       * Set up listener to detect first user interaction
       * This enables TTS after user clicks/types (required by browser autoplay policy)
       */
      function setupUserInteractionListener() {
        const interactionHandler = () => {
          if (!state.userHasInteracted) {
            state.userHasInteracted = true;
            console.log('üé§ User interaction detected - TTS enabled');

            // Speak welcome message on first interaction if not already spoken
            if (!state.welcomeSpoken) {
              speakWelcomeMessage();
            }
          }
        };

        // Listen for any user interaction
        document.addEventListener('click', interactionHandler, { once: false });
        document.addEventListener('keydown', interactionHandler, { once: false });
        document.addEventListener('touchstart', interactionHandler, { once: false });

        console.log('üé§ Waiting for user interaction to enable TTS (browser autoplay policy)');
      }

      /**
       * Speak welcome message with TTS
       * Only called after user has interacted with the page
       */
      async function speakWelcomeMessage() {
        // Check if already spoken
        if (state.welcomeSpoken) {
          return;
        }

        // Check if user has interacted (required for autoplay)
        if (!state.userHasInteracted) {
          console.log('üé§ Welcome speech deferred - waiting for user interaction');
          return;
        }

        const vhEnabled = localStorage.getItem('pmerit_vh_enabled') !== 'false';
        if (!window.TTS || !vhEnabled) {
          console.log('üé§ Welcome speech skipped - TTS:', !!window.TTS, 'VH:', vhEnabled);
          return;
        }

        // Mark as spoken to prevent repeats
        state.welcomeSpoken = true;

        // Get a short welcome message based on session state
        let welcomeText;
        if (state.courseData?.title) {
          welcomeText = `Welcome to ${state.courseData.title}. I'm your AI tutor. Ask me anything!`;
        } else {
          welcomeText = "Hello! I'm your AI tutor. How can I help you today?";
        }

        console.log('üé§ Speaking welcome message:', welcomeText);

        try {
          await window.TTS.speak(welcomeText);
          console.log('üé§ Welcome speech completed');
        } catch (error) {
          console.warn('üé§ Welcome speech failed:', error.message);
          // Reset flag so we can try again
          state.welcomeSpoken = false;
        }
      }

      // Show error message
      function showError(message) {
        dom.lessonTitle.textContent = 'Error';
        dom.playerArea.innerHTML = `
          <div style="text-align: center; padding: 40px; color: var(--color-error, #C4314B);">
            <i class="fas fa-exclamation-circle" style="font-size: 48px; margin-bottom: 16px;"></i>
            <p>${message}</p>
            <a href="../dashboard.html" class="btn" style="margin-top: 20px;">
              <i class="fas fa-home"></i> Return to Dashboard
            </a>
          </div>
        `;
      }

      // Load course modules from API
      async function loadCourseModules() {
        try {
          const modules = await window.ClassroomSession.getCourseModules(courseId);
          state.modules = modules;
          renderOutline();

          // Load first lesson if no specific lesson requested
          if (!lessonId && modules.length > 0 && modules[0].lessons?.length > 0) {
            const firstLesson = modules[0].lessons[0];
            await loadLesson(firstLesson.lesson_id);
          } else if (lessonId) {
            await loadLesson(lessonId);
          }
        } catch (error) {
          console.error('Failed to load modules:', error);
        }
      }

      // Load lesson content
      async function loadLesson(lessonId) {
        try {
          const data = await window.ClassroomSession.getLessonDetails(lessonId);
          state.currentLesson = data.lesson;
          state.lessonId = lessonId;

          // Update UI
          dom.lessonTitle.textContent = `${state.courseData?.title || 'Course'} - ${data.lesson.title}`;

          // Render lesson content
          renderLessonContent(data.lesson);

          // Update navigation buttons
          updateNavigation(data.navigation);

          // Update session with current lesson (only if session exists)
          if (window.ClassroomSession?.hasActiveSession?.()) {
            await window.ClassroomSession.updateProgress({
              lesson_id: lessonId
            });
          }

          // Reset progress bar for new lesson
          updateProgressBar(0);

          // Update outline to show active lesson
          renderOutline();

          // Update stats
          updateStats();

        } catch (error) {
          console.error('Failed to load lesson:', error);
        }
      }

      // Render lesson content in player area
      function renderLessonContent(lesson) {
        const typeIcon = {
          video: 'fa-play-circle',
          reading: 'fa-book-open',
          interactive: 'fa-hand-pointer',
          quiz: 'fa-question-circle',
          project: 'fa-project-diagram',
          discussion: 'fa-comments'
        };

        const icon = typeIcon[lesson.lesson_type] || 'fa-file';
        const duration = lesson.estimated_duration_minutes
          ? `${lesson.estimated_duration_minutes} min`
          : '';

        let contentHTML = `
          <div class="lesson-header" style="margin-bottom: 20px;">
            <h3><i class="fas ${icon}"></i> ${lesson.title}</h3>
            <div class="lesson-meta" style="color: var(--text-secondary); font-size: 0.9rem; margin-top: 8px;">
              <span><i class="fas fa-clock"></i> ${duration}</span>
              <span style="margin-left: 16px;"><i class="fas fa-layer-group"></i> ${lesson.module_title || 'Module'}</span>
            </div>
          </div>
        `;

        // Render based on lesson type
        if (lesson.lesson_type === 'video' && lesson.content_url) {
          contentHTML += `
            <div class="video-container" style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; border-radius: 8px;">
              <iframe src="${lesson.content_url}" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border: none;" allowfullscreen></iframe>
            </div>
          `;
        } else if (lesson.transcript) {
          contentHTML += `
            <div class="lesson-content" style="background: var(--bg-elevated); padding: 20px; border-radius: 8px; max-height: 400px; overflow-y: auto;">
              ${lesson.transcript}
            </div>
          `;
        } else {
          contentHTML += `
            <div class="lesson-placeholder" style="text-align: center; padding: 60px; background: var(--bg-elevated); border-radius: 8px;">
              <i class="fas ${icon}" style="font-size: 64px; color: var(--color-secondary); margin-bottom: 16px;"></i>
              <p>Lesson content is being prepared.</p>
              <p style="color: var(--text-secondary); margin-top: 8px;">Use the AI tutor chat to ask questions about this topic.</p>
            </div>
          `;
        }

        dom.playerArea.innerHTML = contentHTML;
      }

      // Fallback to demo data if API fails
      async function loadCourseDataFallback() {
        const demoData = {
          id: courseId || 'demo-course',
          title: "Introduction to PMERIT Classroom",
          modules: [
            {
              id: 'mod-1',
              title: "Module 1: Getting Started",
              lessons: [
                { lesson_id: 'les-1', title: "Welcome to PMERIT", lesson_type: "video", estimated_duration_minutes: 3 },
                { lesson_id: 'les-2', title: "How to Use This Platform", lesson_type: "video", estimated_duration_minutes: 5 }
              ]
            },
            {
              id: 'mod-2',
              title: "Module 2: Core Concepts",
              lessons: [
                { lesson_id: 'les-3', title: "Basic Principles", lesson_type: "video", estimated_duration_minutes: 7 },
                { lesson_id: 'les-4', title: "Advanced Techniques", lesson_type: "reading", estimated_duration_minutes: 10 }
              ]
            }
          ]
        };

        state.courseData = demoData;
        state.modules = demoData.modules;
        dom.lessonTitle.textContent = demoData.title;
      }

      // Initialize Avatar Manager
      // NOTE: In classroom, GPUStreaming handles WebGL rendering.
      // AvatarManager is only used for TTS/audio, NOT for canvas rendering.
      async function initAvatarManager(enabled) {
        try {
          if (!window.AvatarManager) {
            console.warn('AvatarManager not loaded - using GPUStreaming only');
            updateVHStatus('Virtual Human is ready');
            return;
          }

          // Create AvatarManager but DISABLE its WebGL provider
          // (GPUStreaming handles all canvas rendering)
          state.avatarManager = new window.AvatarManager({
            canvasId: null, // Don't use canvas - GPUStreaming handles it
            captionsId: 'vh-captions',
            enabled: false, // Disable WebGL provider
            apiBaseUrl: window.CONFIG?.API_BASE_URL || 'https://pmerit-api-worker.peoplemerit.workers.dev',
            onSpeakStart: () => {
              dom.vhContainer.classList.add('speaking');
              dom.avatarFrame?.classList.add('speaking');
            },
            onSpeakEnd: () => {
              dom.vhContainer.classList.remove('speaking');
              dom.avatarFrame?.classList.remove('speaking');
            },
            onError: null
          });

          // Initialize for TTS only (no WebGL)
          await state.avatarManager.init();
          console.log('AvatarManager initialized for TTS only (GPUStreaming handles rendering)');

          if (enabled) {
            updateVHStatus('Virtual Human is ready');
            const userTier = getUserTier();
            setAvatarTier(userTier);
          } else {
            dom.vhContainer.classList.add('audio-only');
            setAvatarTier('fallback');
            updateVHStatus('Virtual Human disabled');
          }
        } catch (error) {
          console.warn('Avatar init graceful fallback:', error.message);
          updateVHStatus('Ready (basic mode)');
        }
      }

      // Helper to update VH status text
      function updateVHStatus(text) {
        const statusText = document.getElementById('vh-status-text');
        if (statusText) {
          statusText.textContent = text;
        }
      }

      // Get user subscription tier
      function getUserTier() {
        // Check user subscription from localStorage or API
        const user = window.AUTH?.getCurrentUser();
        const tier = user?.subscription_tier || localStorage.getItem('pmerit_user_tier') || 'standard';
        return tier; // 'premium', 'standard', 'free', or 'fallback'
      }

      // =========================================
      // DIGITAL DESK MODULES (Phase 2-4)
      // =========================================

      // Initialize GPU Streaming for tiered avatar rendering
      async function initGPUStreaming() {
        if (!window.GPUStreaming) {
          console.warn('GPUStreaming module not loaded - using fallback');
          showAvatarError({ message: 'WebGL not available' });
          return null;
        }

        try {
          const gpuStreaming = await window.createGPUStreaming(dom.avatarFrame, {
            idleTimeout: 300000, // 5 minutes
            maxSessionDuration: 3600000 // 1 hour
          });

          // Listen for tier changes
          gpuStreaming.onTierChange((newTier, previousTier) => {
            console.log(`Avatar tier changed: ${previousTier} -> ${newTier}`);
            setAvatarTier(newTier);
          });

          // Listen for connection changes
          gpuStreaming.onConnectionChange((isConnected) => {
            if (isConnected) {
              console.log('GPU streaming connected');
            } else {
              console.log('GPU streaming disconnected');
            }
          });

          // Listen for cost updates
          gpuStreaming.onCostUpdate((costCents) => {
            console.log(`Session cost: $${(costCents / 100).toFixed(2)}`);
          });

          // Listen for errors - SILENT FALLBACK
          gpuStreaming.onError((type, message) => {
            console.warn(`GPU streaming error (${type}):`, message);
            // Silent fallback - no scary error screens
            showAvatarError({ message });
          });

          // Start streaming to load the avatar
          // Check if VH is enabled before starting
          const vhEnabled = localStorage.getItem('pmerit_vh_enabled') !== 'false';
          if (vhEnabled) {
            console.log('üé¨ Starting avatar streaming...');
            await gpuStreaming.startStreaming();
            updateVHStatus('Ready');
          }

          return gpuStreaming;
        } catch (error) {
          console.error('Failed to initialize GPU streaming:', error);
          // Silent fallback
          showAvatarError(error);
          return null;
        }
      }

      // Initialize Vision AI for proctored exams
      async function initVisionAI() {
        if (!window.VisionAI) {
          console.warn('VisionAI module not loaded');
          return null;
        }

        // Only initialize when entering an exam
        return null; // Will be initialized on-demand
      }

      // Start a proctored exam session
      async function startProctoredExam(examData) {
        if (!window.ProctorController) {
          console.error('ProctorController module not loaded');
          return false;
        }

        try {
          // Create proctor session
          const proctor = await window.createProctorSession(examData, {
            maxViolations: 3,
            enableVisionAI: true,
            timerWarningMinutes: 5,
            timerCriticalMinutes: 1,
            onViolation: (violation) => {
              console.warn('Proctor violation:', violation);
            },
            onExamEnd: (result) => {
              console.log('Exam ended:', result);
              endProctoredExam();
            }
          });

          // Initialize Vision AI if enabled
          if (examData.enableVisionAI !== false) {
            const visionAI = await window.createVisionAI('vision-ai-video', {
              faceDetectionInterval: 1000,
              gazeThreshold: 0.3,
              confidenceThreshold: 0.7
            });

            if (visionAI) {
              // Connect Vision AI to Proctor Controller
              proctor.setVisionAI(visionAI);

              // Start detection
              await visionAI.startDetection();
            }
          }

          // Enter proctor mode
          proctor.enterProctorMode();

          return proctor;

        } catch (error) {
          console.error('Failed to start proctored exam:', error);
          return false;
        }
      }

      // End proctored exam
      async function endProctoredExam() {
        if (window.proctorController) {
          // Vision AI cleanup
          if (window.proctorController.visionAI) {
            window.proctorController.visionAI.destroy();
          }

          // Exit proctor mode
          window.proctorController.exitProctorMode();
        }
      }

      // Expose functions globally for testing
      window.startProctoredExam = startProctoredExam;
      window.endProctoredExam = endProctoredExam;

      // Set avatar tier styling
      function setAvatarTier(tier) {
        if (!dom.avatarFrame) return;

        // Remove all tier classes
        dom.avatarFrame.classList.remove('tier-free', 'tier-standard', 'tier-premium', 'tier-fallback');

        // Add new tier class
        dom.avatarFrame.classList.add(`tier-${tier}`);

        // Update live badge
        if (dom.avatarLiveBadge) {
          if (tier === 'premium') {
            dom.avatarLiveBadge.innerHTML = '<span class="live-dot"></span> LIVE HD';
            dom.avatarLiveBadge.classList.add('premium', 'hd');
            dom.avatarLiveBadge.style.display = 'flex';
          } else if (tier === 'standard') {
            dom.avatarLiveBadge.innerHTML = '<span class="live-dot"></span> LIVE';
            dom.avatarLiveBadge.classList.remove('premium', 'hd');
            dom.avatarLiveBadge.style.display = 'flex';
          } else {
            dom.avatarLiveBadge.style.display = 'none';
          }
        }

        // Update fallback visibility
        if (dom.avatarFallback) {
          dom.avatarFallback.style.display = tier === 'fallback' ? 'flex' : 'none';
        }

        console.log(`Avatar tier set to: ${tier}`);
      }

      // Bind event handlers
      function bindEvents() {
        dom.saveNotesBtn.addEventListener('click', saveNotes);
        dom.fileUpload.addEventListener('change', handleFileUpload);
        dom.endClassBtn.addEventListener('click', endClass);
        dom.chatForm.addEventListener('submit', handleChatSubmit);
        dom.vhToggle.addEventListener('click', toggleVirtualHuman);

        // New control handlers
        dom.raiseHandBtn.addEventListener('click', handleRaiseHand);
        dom.prevLessonBtn.addEventListener('click', handlePrevLesson);
        dom.nextLessonBtn.addEventListener('click', handleNextLesson);
        dom.pauseBtn.addEventListener('click', handlePauseResume);
        dom.bookmarkBtn.addEventListener('click', handleBookmark);

        // Tab switching for left panel
        setupTabSwitching();

        // Widget controls
        setupWidgetControls();

        // Mobile panel controls
        setupMobilePanels();

        // Avatar settings panel
        setupAvatarSettings();
      }

      // =========================================
      // AVATAR SETTINGS PANEL
      // =========================================
      function setupAvatarSettings() {
        const settingsBtn = document.getElementById('avatar-settings-btn');
        const chatVoiceSettingsBtn = document.getElementById('chat-voice-settings-btn'); // New visible button
        const settingsModal = document.getElementById('avatar-settings-modal');
        const closeBtn = document.getElementById('avatar-settings-close');
        const saveBtn = document.getElementById('avatar-settings-save');
        const speechRateInput = document.getElementById('speech-rate');
        const speechRateValue = document.getElementById('speech-rate-value');
        const voiceSelect = document.getElementById('voice-select');
        const voiceDescription = document.getElementById('voice-description');
        const previewVoiceBtn = document.getElementById('preview-voice-btn');
        const avatarEnabled = document.getElementById('avatar-enabled');
        const captionsEnabled = document.getElementById('captions-enabled');
        const premiumModal = document.getElementById('premium-upsell-modal');
        const premiumUpgradeBtn = document.getElementById('premium-upgrade-btn');
        const premiumCancelBtn = document.getElementById('premium-cancel-btn');

        if (!settingsModal) return;

        // Voice descriptions (Session 65: Updated for Browser TTS architecture)
        const voiceDescriptions = {
          'standard-male': 'Professor Merit - Clear male voice (Browser TTS)',
          'standard-female': 'Dr. Ada - Clear female voice (Browser TTS)',
          'standard-young': 'Assistant - Friendly young voice (Browser TTS)',
          'browser': 'Uses your device\'s built-in text-to-speech',
          'primo': '‚≠ê Premium - Ultra-natural male voice (Piper TTS)',
          'primo-female': '‚≠ê Premium - Ultra-natural female voice (Piper TTS)'
        };

        // Populate browser voices dynamically
        function populateBrowserVoices() {
          const browserOptgroup = voiceSelect.querySelector('optgroup[label="Browser Voices (Natural)"]');
          if (!browserOptgroup || !window.speechSynthesis) return;

          const voices = speechSynthesis.getVoices();
          if (voices.length === 0) return;

          // Clear existing options except the auto-select one
          while (browserOptgroup.children.length > 1) {
            browserOptgroup.removeChild(browserOptgroup.lastChild);
          }

          // Add high-quality English voices
          const englishVoices = voices.filter(v =>
            v.lang.startsWith('en') &&
            (v.name.includes('Microsoft') || v.name.includes('Google') || v.localService)
          ).slice(0, 5); // Limit to 5 best voices

          englishVoices.forEach(voice => {
            const option = document.createElement('option');
            option.value = `browser:${voice.name}`;
            const label = voice.name.replace('Microsoft ', '').replace('Google ', '');
            option.textContent = label.substring(0, 30);
            browserOptgroup.appendChild(option);
          });
        }

        // Populate voices when available
        if (window.speechSynthesis) {
          populateBrowserVoices();
          speechSynthesis.onvoiceschanged = populateBrowserVoices;
        }

        // Load saved settings
        const settings = window.TTS?.getSettings() || {};
        speechRateInput.value = settings.speechRate || 0.85;
        speechRateValue.textContent = (settings.speechRate || 0.85).toFixed(2) + 'x';
        voiceSelect.value = settings.voiceEngine || 'standard-male';
        avatarEnabled.checked = localStorage.getItem('pmerit_vh_enabled') !== 'false';
        captionsEnabled.checked = localStorage.getItem('pmerit_captions_enabled') !== 'false';

        // Update voice description
        function updateVoiceDescription() {
          const voice = voiceSelect.value;
          if (voice.startsWith('browser:')) {
            voiceDescription.textContent = 'Browser voice: ' + voice.replace('browser:', '');
          } else {
            voiceDescription.textContent = voiceDescriptions[voice] || 'Server-generated voice';
          }
        }
        updateVoiceDescription();

        // Update description when voice changes
        voiceSelect.addEventListener('change', () => {
          updateVoiceDescription();

          // Check if premium voice selected
          const selectedOption = voiceSelect.selectedOptions[0];
          if (selectedOption && selectedOption.dataset.premium === 'true') {
            // Check if user has premium (for now, assume not - will integrate with subscription system)
            const hasPremium = localStorage.getItem('pmerit_subscription_tier') === 'premium';
            if (!hasPremium && premiumModal) {
              premiumModal.style.display = 'flex';
            }
          }
        });

        // Update rate display when slider changes
        speechRateInput.addEventListener('input', () => {
          speechRateValue.textContent = parseFloat(speechRateInput.value).toFixed(2) + 'x';
        });

        // Voice preview functionality
        // FIX (Session 65): Use TTS.speak() to ensure voice differentiation is applied
        let previewAudio = null;
        previewVoiceBtn?.addEventListener('click', async () => {
          const voice = voiceSelect.value;
          const previewText = 'Hello! I\'m your AI tutor. Let me help you learn today.';

          // Stop any current preview
          if (previewAudio) {
            previewAudio.pause();
            previewAudio = null;
          }
          window.TTS?.stop();

          // Update button state
          previewVoiceBtn.classList.add('playing');
          previewVoiceBtn.disabled = true;
          previewVoiceBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';

          const resetButton = () => {
            previewVoiceBtn.classList.remove('playing');
            previewVoiceBtn.disabled = false;
            previewVoiceBtn.innerHTML = '<i class="fas fa-play"></i>';
          };

          try {
            // IMPORTANT: First save the voice selection so TTS.speak uses it
            if (window.TTS) {
              window.TTS.setVoiceEngine(voice);
              window.TTS.setSpeechRate(parseFloat(speechRateInput.value));
            }

            // Check if this is a premium voice that requires server
            const voiceConfig = window.TTS?.getVoiceOptions()?.[voice];
            const isPremiumVoice = voiceConfig?.tier === 'premium';

            if (isPremiumVoice) {
              // Server voice preview (premium voices via RunPod)
              const apiBase = window.CONFIG?.API_BASE_URL || 'https://pmerit-api-worker.peoplemerit.workers.dev';
              const res = await fetch(`${apiBase}/api/v1/tts`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ text: previewText, voice: voice })
              });

              if (!res.ok) throw new Error('Preview failed');

              const blob = await res.blob();
              const url = URL.createObjectURL(blob);
              previewAudio = new Audio(url);
              previewAudio.playbackRate = parseFloat(speechRateInput.value);

              previewAudio.onended = () => {
                resetButton();
                URL.revokeObjectURL(url);
                previewAudio = null;
              };
              previewAudio.onerror = previewAudio.onended;

              await previewAudio.play();
            } else {
              // FREE VOICES: Use TTS.speak() which applies pitch/rate differentiation
              // This is the FIX for Session 65 - ensures male/female/young sound different
              console.log(`üé§ Preview: Using TTS.speak() for free voice: ${voice}`);

              // Listen for TTS end event to reset button
              const handleTTSEnd = () => {
                resetButton();
                document.removeEventListener('tts:end', handleTTSEnd);
              };
              document.addEventListener('tts:end', handleTTSEnd);

              // Use TTS module which applies voice differentiation (pitch/rate)
              await window.TTS.speak(previewText);
            }
          } catch (error) {
            console.error('Voice preview failed:', error);
            resetButton();
          }
        });

        // Premium upsell modal handlers
        premiumUpgradeBtn?.addEventListener('click', () => {
          // Navigate to subscription page
          window.location.href = '/portal/subscription.html?upgrade=premium&source=voice';
        });

        premiumCancelBtn?.addEventListener('click', () => {
          premiumModal.style.display = 'none';
          // Reset to default free voice
          voiceSelect.value = 'standard-male';
          updateVoiceDescription();
        });

        // Close premium modal on background click
        premiumModal?.addEventListener('click', (e) => {
          if (e.target === premiumModal) {
            premiumModal.style.display = 'none';
            voiceSelect.value = 'standard-male';
            updateVoiceDescription();
          }
        });

        // Open modal - Avatar gear button (if exists)
        if (settingsBtn) {
          settingsBtn.addEventListener('click', () => {
            settingsModal.style.display = 'flex';
          });
        }

        // Open modal - Chat header voice settings button (always visible)
        if (chatVoiceSettingsBtn) {
          chatVoiceSettingsBtn.addEventListener('click', () => {
            settingsModal.style.display = 'flex';
          });
        }

        // Close modal
        closeBtn.addEventListener('click', () => {
          settingsModal.style.display = 'none';
        });

        // Close on background click
        settingsModal.addEventListener('click', (e) => {
          if (e.target === settingsModal) {
            settingsModal.style.display = 'none';
          }
        });

        // Save settings
        saveBtn.addEventListener('click', () => {
          // Save TTS settings
          if (window.TTS) {
            window.TTS.setSpeechRate(parseFloat(speechRateInput.value));
            window.TTS.setVoiceEngine(voiceSelect.value);
          }

          // Save avatar/captions preferences
          localStorage.setItem('pmerit_vh_enabled', avatarEnabled.checked);
          localStorage.setItem('pmerit_captions_enabled', captionsEnabled.checked);

          // Apply avatar visibility immediately
          const avatarContainer = document.getElementById('sidebar-avatar');
          if (avatarContainer) {
            avatarContainer.style.display = avatarEnabled.checked ? 'block' : 'none';
          }

          // Update VH toggle state
          updateVHToggle(avatarEnabled.checked);

          // Close modal
          settingsModal.style.display = 'none';

          console.log('‚úÖ Avatar settings saved:', {
            speechRate: speechRateInput.value,
            voice: voiceSelect.value,
            avatarEnabled: avatarEnabled.checked,
            captionsEnabled: captionsEnabled.checked
          });
        });
      }

      // =========================================
      // MOBILE PANEL CONTROLS
      // =========================================
      function setupMobilePanels() {
        const leftPanel = document.querySelector('.classroom-panel--left');
        const rightPanel = document.querySelector('.classroom-panel--right');
        const mobileToggle = document.getElementById('mobile-menu-toggle');
        const mobileOverlay = document.getElementById('mobile-overlay');
        const chatHeader = document.querySelector('.chat-header');

        if (!leftPanel || !mobileToggle) return;

        // Toggle left panel (course outline)
        mobileToggle.addEventListener('click', () => {
          const isOpen = leftPanel.classList.toggle('open');
          mobileOverlay.classList.toggle('active', isOpen);
          mobileToggle.innerHTML = isOpen
            ? '<i class="fas fa-times"></i>'
            : '<i class="fas fa-list"></i>';
        });

        // Close left panel when clicking overlay
        mobileOverlay.addEventListener('click', () => {
          leftPanel.classList.remove('open');
          mobileOverlay.classList.remove('active');
          mobileToggle.innerHTML = '<i class="fas fa-list"></i>';
        });

        // Close left panel when selecting a lesson on mobile
        leftPanel.addEventListener('click', (e) => {
          if (e.target.closest('.outline-lesson') && window.innerWidth <= 768) {
            setTimeout(() => {
              leftPanel.classList.remove('open');
              mobileOverlay.classList.remove('active');
              mobileToggle.innerHTML = '<i class="fas fa-list"></i>';
            }, 100);
          }
        });

        // Chat panel expand/collapse on mobile
        if (chatHeader && rightPanel) {
          chatHeader.addEventListener('click', (e) => {
            if (window.innerWidth <= 768) {
              rightPanel.classList.toggle('expanded');
            }
          });

          // Swipe gesture support for chat panel
          let touchStartY = 0;
          let touchEndY = 0;

          rightPanel.addEventListener('touchstart', (e) => {
            touchStartY = e.touches[0].clientY;
          }, { passive: true });

          rightPanel.addEventListener('touchend', (e) => {
            touchEndY = e.changedTouches[0].clientY;
            const diff = touchStartY - touchEndY;

            // Swipe up to expand (diff > 50), swipe down to collapse (diff < -50)
            if (Math.abs(diff) > 50 && window.innerWidth <= 768) {
              if (diff > 50) {
                rightPanel.classList.add('expanded');
              } else {
                rightPanel.classList.remove('expanded');
              }
            }
          }, { passive: true });
        }

        // Handle resize - reset panel states when going back to desktop
        window.addEventListener('resize', () => {
          if (window.innerWidth > 768) {
            leftPanel.classList.remove('open');
            rightPanel?.classList.remove('expanded');
            mobileOverlay.classList.remove('active');
          }
        });
      }

      // =========================================
      // TAB SWITCHING (Left Panel)
      // =========================================
      function setupTabSwitching() {
        const tabs = document.querySelectorAll('.panel-tab');
        const panes = document.querySelectorAll('.tab-pane');

        tabs.forEach(tab => {
          tab.addEventListener('click', () => {
            const tabId = tab.getAttribute('data-tab');

            // Update tab active states
            tabs.forEach(t => t.classList.remove('active'));
            tab.classList.add('active');

            // Update pane visibility
            panes.forEach(pane => {
              pane.classList.remove('active');
              if (pane.id === `tab-${tabId}`) {
                pane.classList.add('active');
              }
            });
          });
        });
      }

      // =========================================
      // FLOATING WIDGET CONTROLS
      // =========================================
      function setupWidgetControls() {
        const widget = document.getElementById('vh-root');
        const dragHandle = document.getElementById('widget-drag-handle');
        const minimizeBtn = document.getElementById('widget-minimize');
        const closeBtn = document.getElementById('widget-close');

        if (!widget) return;

        // Make widget draggable
        let isDragging = false;
        let hasMoved = false;
        let startX, startY, startLeft, startTop;
        const isMobile = () => window.innerWidth <= 768;

        // Snap to nearest corner on mobile
        function snapToCorner() {
          if (!isMobile()) return;

          const rect = widget.getBoundingClientRect();
          const centerX = rect.left + rect.width / 2;
          const centerY = rect.top + rect.height / 2;
          const screenCenterX = window.innerWidth / 2;
          const screenCenterY = window.innerHeight / 2;

          // Determine which corner/edge to snap to
          const padding = 12;
          const bottomSafe = 70; // Above playback controls

          let targetLeft, targetTop;

          // Horizontal: left or right edge
          if (centerX < screenCenterX) {
            targetLeft = padding;
          } else {
            targetLeft = window.innerWidth - rect.width - padding;
          }

          // Vertical: top third, middle, or bottom third
          if (centerY < window.innerHeight * 0.33) {
            targetTop = padding + 50; // Below header
          } else if (centerY > window.innerHeight * 0.66) {
            targetTop = window.innerHeight - rect.height - bottomSafe;
          } else {
            // Middle - keep vertical position but snap horizontal
            targetTop = Math.max(50, Math.min(rect.top, window.innerHeight - rect.height - bottomSafe));
          }

          // Animate to corner
          widget.style.transition = 'left 0.3s ease, top 0.3s ease';
          widget.style.left = targetLeft + 'px';
          widget.style.top = targetTop + 'px';
          widget.style.bottom = 'auto';
          widget.style.right = 'auto';

          // Remove transition after animation
          setTimeout(() => {
            widget.style.transition = '';
          }, 300);

          // Save position
          localStorage.setItem('pmerit_mobile_avatar_pos', JSON.stringify({
            left: targetLeft,
            top: targetTop
          }));
        }

        // Desktop: drag by header only
        if (dragHandle) {
          dragHandle.addEventListener('mousedown', (e) => {
            if (e.target.closest('.avatar-pip__btn')) return;
            isDragging = true;
            hasMoved = false;
            widget.classList.add('dragging');
            startX = e.clientX;
            startY = e.clientY;
            const rect = widget.getBoundingClientRect();
            startLeft = rect.left;
            startTop = rect.top;
            e.preventDefault();
          });
        }

        document.addEventListener('mousemove', (e) => {
          if (!isDragging) return;
          hasMoved = true;
          const dx = e.clientX - startX;
          const dy = e.clientY - startY;
          let newLeft = startLeft + dx;
          let newTop = startTop + dy;
          const maxLeft = window.innerWidth - widget.offsetWidth - 10;
          const maxTop = window.innerHeight - widget.offsetHeight - 10;
          newLeft = Math.max(10, Math.min(newLeft, maxLeft));
          newTop = Math.max(10, Math.min(newTop, maxTop));
          widget.style.left = newLeft + 'px';
          widget.style.top = newTop + 'px';
          widget.style.right = 'auto';
          widget.style.bottom = 'auto';
        });

        document.addEventListener('mouseup', () => {
          if (isDragging) {
            isDragging = false;
            widget.classList.remove('dragging');
            if (hasMoved) {
              if (isMobile()) {
                snapToCorner();
              } else {
                localStorage.setItem('pmerit_widget_pos', JSON.stringify({
                  left: widget.style.left,
                  top: widget.style.top
                }));
              }
            }
          }
        });

        // MOBILE: Touch support - drag entire widget
        widget.addEventListener('touchstart', (e) => {
          if (!isMobile()) return;
          if (e.target.closest('.avatar-pip__btn') || e.target.closest('.chat-input')) return;

          const touch = e.touches[0];
          isDragging = true;
          hasMoved = false;
          widget.classList.add('dragging');
          startX = touch.clientX;
          startY = touch.clientY;
          const rect = widget.getBoundingClientRect();
          startLeft = rect.left;
          startTop = rect.top;
        }, { passive: true });

        document.addEventListener('touchmove', (e) => {
          if (!isDragging || !isMobile()) return;

          const touch = e.touches[0];
          const dx = touch.clientX - startX;
          const dy = touch.clientY - startY;

          // Only count as moved if dragged more than 10px
          if (Math.abs(dx) > 10 || Math.abs(dy) > 10) {
            hasMoved = true;
          }

          if (!hasMoved) return;

          let newLeft = startLeft + dx;
          let newTop = startTop + dy;
          const maxLeft = window.innerWidth - widget.offsetWidth - 10;
          const maxTop = window.innerHeight - widget.offsetHeight - 70; // Above playback
          newLeft = Math.max(10, Math.min(newLeft, maxLeft));
          newTop = Math.max(50, Math.min(newTop, maxTop));

          widget.style.left = newLeft + 'px';
          widget.style.top = newTop + 'px';
          widget.style.right = 'auto';
          widget.style.bottom = 'auto';
        }, { passive: true });

        document.addEventListener('touchend', () => {
          if (isDragging && isMobile()) {
            isDragging = false;
            widget.classList.remove('dragging');
            if (hasMoved) {
              snapToCorner();
            }
          }
        });

        // Restore saved position on load
        if (isMobile()) {
          const savedPos = localStorage.getItem('pmerit_mobile_avatar_pos');
          if (savedPos) {
            try {
              const pos = JSON.parse(savedPos);
              widget.style.left = pos.left + 'px';
              widget.style.top = pos.top + 'px';
              widget.style.right = 'auto';
              widget.style.bottom = 'auto';
            } catch (e) { /* ignore */ }
          }
        } else {
          const savedPos = localStorage.getItem('pmerit_widget_pos');
          if (savedPos) {
            try {
              const pos = JSON.parse(savedPos);
              widget.style.left = pos.left;
              widget.style.top = pos.top;
              widget.style.right = 'auto';
            } catch (e) { /* ignore */ }
          }
        }

        // Minimize button (desktop only)
        if (minimizeBtn) {
          minimizeBtn.addEventListener('click', () => {
            widget.classList.toggle('minimized');
            const icon = minimizeBtn.querySelector('i');
            if (widget.classList.contains('minimized')) {
              icon.className = 'fas fa-plus';
              minimizeBtn.title = 'Expand';
            } else {
              icon.className = 'fas fa-minus';
              minimizeBtn.title = 'Minimize';
            }
          });
        }

        // Close button (hides widget, toggles VH off)
        if (closeBtn) {
          closeBtn.addEventListener('click', () => {
            toggleVirtualHuman();
          });
        }

        // Show drag hint on mobile for first-time users
        if (isMobile()) {
          const hintShown = localStorage.getItem('pmerit_avatar_drag_hint_shown');
          if (!hintShown) {
            const dragHint = document.getElementById('avatar-drag-hint');
            if (dragHint) {
              // Show hint after 1.5 seconds
              setTimeout(() => {
                dragHint.classList.add('show');

                // Hide hint after 10 seconds (longer for better readability)
                setTimeout(() => {
                  dragHint.classList.remove('show');
                  localStorage.setItem('pmerit_avatar_drag_hint_shown', 'true');
                }, 10000);
              }, 1500);

              // Hide hint immediately if user starts dragging
              widget.addEventListener('touchstart', () => {
                if (dragHint.classList.contains('show')) {
                  dragHint.classList.remove('show');
                  localStorage.setItem('pmerit_avatar_drag_hint_shown', 'true');
                }
              }, { once: true });
            }
          }
        }
      }

      // Handle Raise Hand button
      async function handleRaiseHand() {
        // Focus chat input for question
        dom.chatInput.focus();
        dom.chatInput.placeholder = 'Type your question here...';

        // Visual feedback
        dom.raiseHandBtn.innerHTML = '<i class="fas fa-hand-paper"></i> Hand Raised!';
        dom.raiseHandBtn.style.background = 'var(--color-success, #3A7F5C)';

        // Log interaction
        if (window.ClassroomSession?.hasActiveSession()) {
          await window.ClassroomSession.logInteraction('hand_raise', {
            position: { lessonId: state.lessonId }
          });
          updateStats();
        }

        // Reset button after 3 seconds
        setTimeout(() => {
          dom.raiseHandBtn.innerHTML = '<i class="fas fa-hand-paper"></i> Raise Hand';
          dom.raiseHandBtn.style.background = 'var(--color-secondary, #4AA4B9)';
          dom.chatInput.placeholder = 'Ask your AI tutor...';
        }, 3000);
      }

      // Handle Previous Lesson
      async function handlePrevLesson() {
        if (state.lessonNavigation?.prev_lesson_id) {
          await loadLesson(state.lessonNavigation.prev_lesson_id);
        }
      }

      // Handle Next Lesson
      async function handleNextLesson() {
        if (state.lessonNavigation?.next_lesson_id) {
          // Mark current lesson as completed before moving to next
          if (state.lessonId) {
            markLessonCompleted(state.lessonId);
          }
          await loadLesson(state.lessonNavigation.next_lesson_id);
        }
      }

      // Handle Pause/Resume
      let isPaused = false;
      function handlePauseResume() {
        isPaused = !isPaused;

        if (isPaused) {
          dom.pauseBtn.innerHTML = '<i class="fas fa-play"></i> Resume';
          // Log pause
          if (window.ClassroomSession?.hasActiveSession()) {
            window.ClassroomSession.logInteraction('pause', {
              position: { lessonId: state.lessonId }
            });
          }
        } else {
          dom.pauseBtn.innerHTML = '<i class="fas fa-pause"></i> Pause';
          // Log resume
          if (window.ClassroomSession?.hasActiveSession()) {
            window.ClassroomSession.logInteraction('resume', {
              position: { lessonId: state.lessonId }
            });
          }
        }
      }

      // Handle Bookmark
      async function handleBookmark() {
        // Save bookmark
        const bookmarks = JSON.parse(localStorage.getItem(`pmerit_bookmarks_${courseId}`) || '[]');
        const bookmark = {
          lessonId: state.lessonId,
          lessonTitle: state.currentLesson?.title,
          timestamp: new Date().toISOString()
        };
        bookmarks.push(bookmark);
        localStorage.setItem(`pmerit_bookmarks_${courseId}`, JSON.stringify(bookmarks));

        // Log interaction
        if (window.ClassroomSession?.hasActiveSession()) {
          await window.ClassroomSession.logInteraction('bookmark', {
            position: { lessonId: state.lessonId }
          });
        }

        // Visual feedback
        dom.bookmarkBtn.innerHTML = '<i class="fas fa-bookmark"></i> Saved!';
        dom.bookmarkBtn.style.color = 'var(--color-success, #3A7F5C)';
        setTimeout(() => {
          dom.bookmarkBtn.innerHTML = '<i class="fas fa-bookmark"></i> Bookmark';
          dom.bookmarkBtn.style.color = '';
        }, 2000);
      }

      // Update session stats display
      function updateStats() {
        const sessionState = window.ClassroomSession?.getState() || {};
        dom.statHandRaises.textContent = sessionState.handRaises || 0;
        dom.statQuestions.textContent = sessionState.questionsAsked || 0;
      }

      // Update progress bar
      function updateProgressBar(percent) {
        dom.progressBar.style.width = `${percent}%`;
        dom.progressPercent.textContent = `${Math.round(percent)}%`;
      }

      // Update navigation buttons
      function updateNavigation(navigation) {
        state.lessonNavigation = navigation;
        dom.prevLessonBtn.disabled = !navigation?.prev_lesson_id;
        dom.nextLessonBtn.disabled = !navigation?.next_lesson_id;
      }

      // Toggle Virtual Human
      async function toggleVirtualHuman() {
        const currentlyEnabled = !dom.vhToggle.classList.contains('off');
        const newState = !currentlyEnabled;

        console.log('VH Toggle:', currentlyEnabled, '->', newState);

        updateVHToggle(newState);
        localStorage.setItem('pmerit_vh_enabled', newState.toString());

        if (state.avatarManager) {
          state.avatarManager.setEnabled(newState);
        }

        if (newState) {
          // Turning ON - show VH and initialize if needed
          dom.vhContainer.classList.remove('audio-only');
          updateVHStatus('Initializing...');

          // Initialize avatar manager if not already done
          if (state.avatarManager && !state.avatarManager.state?.initialized) {
            initAvatarManager(true);
          } else if (!state.avatarManager) {
            initAvatarManager(true);
          } else {
            // Already initialized - just update status
            if (state.avatarManager.state?.provider) {
              updateVHStatus('Virtual Human is ready');
            } else {
              updateVHStatus('Ready (audio mode)');
            }
          }

          // Also init/start GPU streaming if available
          if (window.GPUStreaming) {
            if (!state.gpuStreaming) {
              state.gpuStreaming = await initGPUStreaming();
            } else {
              // GPUStreaming exists but may not be streaming
              console.log('üé¨ Starting avatar streaming...');
              await state.gpuStreaming.startStreaming();
              updateVHStatus('Virtual Human is ready');
            }
          }
        } else {
          // Turning OFF - hide VH and stop streaming
          dom.vhContainer.classList.add('audio-only');
          updateVHStatus('Virtual Human disabled');
          if (state.gpuStreaming) {
            state.gpuStreaming.stopStreaming();
          }
        }
      }

      // Update VH toggle UI
      function updateVHToggle(enabled) {
        if (enabled) {
          dom.vhToggle.classList.remove('off');
          // Show vh-root container (avatar-pip)
          dom.vhContainer.classList.remove('hidden');
          dom.vhContainer.setAttribute('aria-hidden', 'false');
        } else {
          dom.vhToggle.classList.add('off');
          // Hide vh-root container (avatar-pip)
          dom.vhContainer.classList.add('hidden');
          dom.vhContainer.setAttribute('aria-hidden', 'true');
        }
      }

      // Load user notes
      function loadUserNotes() {
        const noteKey = `pmerit_notes_${courseId}`;
        const savedNotes = localStorage.getItem(noteKey);
        if (savedNotes) {
          state.notes = JSON.parse(savedNotes);
          dom.notesText.value = state.notes.content || "";
        }
      }

      // Render course outline with completion indicators
      function renderOutline() {
        if (!state.modules || state.modules.length === 0) {
          dom.outlineContainer.innerHTML = '<p style="color: var(--classroom-text-muted);">No modules available.</p>';
          return;
        }

        // Get completed lessons from localStorage
        const completedLessons = JSON.parse(localStorage.getItem(`pmerit_completed_${state.courseId}`) || '[]');

        let outlineHTML = '';
        state.modules.forEach((module, moduleIndex) => {
          // Count completed lessons in this module
          const moduleLessons = module.lessons || [];
          const completedInModule = moduleLessons.filter(l => completedLessons.includes(l.lesson_id)).length;
          const moduleComplete = moduleLessons.length > 0 && completedInModule === moduleLessons.length;
          const moduleProgress = moduleLessons.length > 0 ? Math.round((completedInModule / moduleLessons.length) * 100) : 0;

          outlineHTML += `
            <div class="outline-module">
              <div class="outline-module__header ${moduleComplete ? 'completed' : ''}">
                <i class="fas ${moduleComplete ? 'fa-folder-open' : 'fa-folder'}"></i>
                <span>${module.title}</span>
                ${moduleProgress > 0 ? `<span class="outline-module__progress">${moduleProgress}%</span>` : ''}
              </div>`;

          if (module.lessons && module.lessons.length > 0) {
            module.lessons.forEach((lesson) => {
              const isActive = state.lessonId === lesson.lesson_id;
              const isCompleted = completedLessons.includes(lesson.lesson_id);
              const icon = isCompleted ? 'fa-check-circle' :
                          lesson.lesson_type === 'video' ? 'fa-play-circle' :
                          lesson.lesson_type === 'reading' ? 'fa-book' : 'fa-file';
              const duration = lesson.estimated_duration_minutes ? `${lesson.estimated_duration_minutes}m` : '';

              outlineHTML += `
                <div class="outline-lesson ${isActive ? 'active' : ''} ${isCompleted ? 'completed' : ''}"
                     data-lesson-id="${lesson.lesson_id}"
                     onclick="window.loadLesson('${lesson.lesson_id}')">
                  <span class="outline-lesson__icon"><i class="fas ${icon}"></i></span>
                  <span class="outline-lesson__title">${lesson.title || lesson.lesson_title}</span>
                  ${duration ? `<span class="outline-lesson__duration">${duration}</span>` : ''}
                </div>
              `;
            });
          }
          outlineHTML += '</div>'; // Close outline-module
        });
        dom.outlineContainer.innerHTML = outlineHTML;
      }

      // Mark lesson as completed
      function markLessonCompleted(lessonId) {
        const completedLessons = JSON.parse(localStorage.getItem(`pmerit_completed_${state.courseId}`) || '[]');
        if (!completedLessons.includes(lessonId)) {
          completedLessons.push(lessonId);
          localStorage.setItem(`pmerit_completed_${state.courseId}`, JSON.stringify(completedLessons));
          renderOutline(); // Re-render to show checkmark
        }
      }

      // Expose for testing
      window.markLessonCompleted = markLessonCompleted;

      // Expose loadLesson globally for outline clicks
      window.loadLesson = async function(lessonId) {
        await loadLesson(lessonId);
      };

      // Save notes
      function saveNotes() {
        state.notes.content = dom.notesText.value;
        state.notes.timestamp = new Date().toISOString();
        localStorage.setItem(`pmerit_notes_${courseId}`, JSON.stringify(state.notes));

        // Log interaction
        if (window.ClassroomSession?.hasActiveSession()) {
          window.ClassroomSession.logInteraction('note', {
            position: { lessonId: state.lessonId }
          });
        }

        // Show success feedback
        const btn = dom.saveNotesBtn;
        const originalText = btn.textContent;
        btn.textContent = '‚úì Saved!';
        btn.style.backgroundColor = 'var(--color-success, #3A7F5C)';
        setTimeout(() => {
          btn.textContent = originalText;
          btn.style.backgroundColor = '';
        }, 2000);
      }

      // Handle file upload
      function handleFileUpload(event) {
        const files = Array.from(event.target.files);
        files.forEach(file => {
          state.resources.push({ name: file.name, size: file.size, type: file.type });
        });
        renderResources();
      }

      // Render resources
      function renderResources() {
        let resourcesHTML = '';
        state.resources.forEach(resource => {
          resourcesHTML += `<div class="resource-item"><strong>${resource.name}</strong> <small>(${formatFileSize(resource.size)})</small></div>`;
        });
        dom.resourcesContainer.innerHTML = resourcesHTML || '<p>No resources uploaded yet.</p>';
      }

      // Format file size
      function formatFileSize(bytes) {
        if (bytes < 1024) return bytes + ' bytes';
        else if (bytes < 1048576) return (bytes / 1024).toFixed(1) + ' KB';
        else return (bytes / 1048576).toFixed(1) + ' MB';
      }

      // Handle chat submit - uses real AI API
      async function handleChatSubmit(event) {
        event.preventDefault();
        const message = dom.chatInput.value.trim();
        if (!message) return;

        addChatMessage('user', message);
        dom.chatInput.value = '';

        // Log hand raise interaction
        const startTime = Date.now();
        if (window.ClassroomSession?.hasActiveSession()) {
          await window.ClassroomSession.raiseHand(message);
        }

        // Call AI Tutor API
        try {
          // Build context with grade_code if available (enables persona selection)
          const user = window.AUTH?.getCurrentUser();
          const tutorContext = {};
          if (user?.gradeCode) {
            tutorContext.grade_code = user.gradeCode;
          }
          if (user?.personaOverride) {
            tutorContext.persona_override = user.personaOverride;
          }

          // Lesson context for RAG-enhanced tutoring (Session 17: P0-2 Fix)
          if (state.lessonId) {
            tutorContext.lesson_id = state.lessonId;
          }
          if (state.courseId) {
            tutorContext.course_id = state.courseId;
          }

          const response = await fetch(`${window.CONFIG?.API_BASE_URL || 'https://pmerit-api-worker.peoplemerit.workers.dev'}/api/v1/ai/tutor`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              messages: state.chatMessages.concat([{ role: 'user', content: message }]),
              context: Object.keys(tutorContext).length > 0 ? tutorContext : undefined
            })
          });

          // Handle streaming response
          const reader = response.body.getReader();
          const decoder = new TextDecoder();
          let aiResponse = '';

          while (true) {
            const { done, value } = await reader.read();
            if (done) break;

            const chunk = decoder.decode(value, { stream: true });
            // Parse SSE data
            const lines = chunk.split('\n');
            for (const line of lines) {
              if (line.startsWith('data: ')) {
                try {
                  const data = JSON.parse(line.slice(6));
                  if (data.response) {
                    aiResponse += data.response;
                  }
                } catch (e) {
                  // Not JSON, might be raw text
                  aiResponse += line.slice(6);
                }
              }
            }
          }

          // Clean up response
          aiResponse = aiResponse.trim() || "I'm here to help! Could you please rephrase your question?";

          // Log response time
          const responseTime = Date.now() - startTime;
          if (window.ClassroomSession?.hasActiveSession()) {
            await window.ClassroomSession.logInteraction('question', {
              question: message,
              response: aiResponse,
              responseTimeMs: responseTime
            });
          }

          // Update chat history
          state.chatMessages.push({ role: 'user', content: message });
          state.chatMessages.push({ role: 'assistant', content: aiResponse });

          addChatMessage('ai', aiResponse);

          // Speak with TTS - this dispatches tts:viseme events for GPUStreaming lip-sync
          const vhEnabled = localStorage.getItem('pmerit_vh_enabled') !== 'false';
          console.log('üé§ TTS Check - TTS available:', !!window.TTS, 'VH enabled:', vhEnabled);
          if (window.TTS && vhEnabled) {
            try {
              console.log('üé§ Starting TTS speech for:', aiResponse.substring(0, 50) + '...');
              await window.TTS.speak(aiResponse);
              console.log('üé§ TTS speech completed');
            } catch (ttsError) {
              console.warn('TTS speech failed:', ttsError.message);
            }
          } else {
            console.log('üé§ TTS skipped - TTS:', !!window.TTS, 'vhEnabled:', vhEnabled);
          }

        } catch (error) {
          console.error('AI chat error:', error);
          addChatMessage('ai', 'I apologize, but I encountered an issue. Please try again.');
        }
      }

      // Add chat message
      function addChatMessage(sender, message) {
        const messageDiv = document.createElement('div');
        messageDiv.classList.add('chat-message', `chat-message--${sender}`);
        messageDiv.textContent = message;
        dom.chatMessages.appendChild(messageDiv);
        dom.chatMessages.scrollTop = dom.chatMessages.scrollHeight;
      }

      // Show avatar error - GRACEFUL FALLBACK (no red error screens)
      function showAvatarError(error) {
        console.warn('Avatar fallback triggered:', error?.message || error);

        // Switch to fallback mode
        dom.vhContainer.classList.add('fallback');

        // Update status text with friendly message
        const statusText = document.getElementById('vh-status-text');
        if (statusText) {
          statusText.textContent = 'Audio-only mode active';
        }

        // Set fallback tier
        setAvatarTier('fallback');

        // Show non-intrusive toast notification instead of blocking error
        showToast('Low bandwidth detected. Using audio-only mode.', 'info');
      }

      // Toast notification helper
      function showToast(message, type = 'info') {
        // Remove existing toast if any
        const existingToast = document.querySelector('.classroom-toast');
        if (existingToast) {
          existingToast.remove();
        }

        const toast = document.createElement('div');
        toast.className = `classroom-toast classroom-toast--${type}`;
        toast.innerHTML = `<i class="fas fa-info-circle"></i> ${message}`;
        document.body.appendChild(toast);

        // Auto-remove after 4 seconds
        setTimeout(() => {
          toast.style.animation = 'toast-out 0.3s ease-in forwards';
          setTimeout(() => toast.remove(), 300);
        }, 4000);
      }

      // End class session
      async function endClass() {
        if (!confirm('Are you sure you want to end this class session?')) {
          return;
        }

        try {
          // End session via API
          if (window.ClassroomSession?.hasActiveSession()) {
            const notes = dom.notesText.value;
            await window.ClassroomSession.endSession(notes);
          }
        } catch (error) {
          console.error('Failed to end session:', error);
        }

        // Clean up avatar
        if (state.avatarManager) {
          state.avatarManager.dispose();
        }

        // Redirect to dashboard
        window.location.href = '../dashboard.html';
      }

      // Start initialization
      document.addEventListener('DOMContentLoaded', init);
    })();
  </script>
</body>
</html>
