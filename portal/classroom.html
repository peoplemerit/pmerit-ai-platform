<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
  <title>Classroom | PMERIT Learner Portal</title>
  <meta name="description" content="Interactive classroom with AI Tutor and Virtual Human">

  <!-- Google Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">

  <!-- Font Awesome -->
  <link
    rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css"
    integrity="sha512-SnH5WK+bZxgPHs44uWIX+LLJAJ9/2PkPKZ5QiAj6Ta86w+fsb2TkcmfRyVX3pBnMFcV7oQPJkl9QevSCWr3W6A=="
    crossorigin="anonymous"
    referrerpolicy="no-referrer">

  <!-- CLASSROOM APP SHELL CSS (v1.0 - Session 47) -->
  <link rel="stylesheet" href="../assets/css/classroom.css">

  <!-- Legacy CSS for components not yet migrated -->
  <link rel="stylesheet" href="../assets/css/avatar.css">
  <link rel="stylesheet" href="../assets/css/proctor-mode.css">

  <!-- Three.js r137 (last version with global THREE.GLTFLoader in examples/js/) -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.137.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.137.0/examples/js/loaders/GLTFLoader.js"></script>
  <!-- Meshopt decoder for compressed GLB models -->
  <script src="https://cdn.jsdelivr.net/npm/meshoptimizer@0.20.0/meshopt_decoder.js"></script>
  <script>
    // Configure GLTFLoader with meshopt decoder after both are loaded
    (async function() {
      if (typeof MeshoptDecoder !== 'undefined') {
        await MeshoptDecoder.ready;
        window.MeshoptDecoderReady = true;
        console.log('‚úÖ MeshoptDecoder ready');
      }
      // Verify GLTFLoader is available
      if (typeof THREE !== 'undefined' && typeof THREE.GLTFLoader !== 'undefined') {
        console.log('‚úÖ THREE.GLTFLoader available (r137)');
      } else {
        console.error('‚ùå THREE.GLTFLoader not found!');
      }
    })();
  </script>
  
  <!-- Auth protection -->
  <script src="../assets/js/config.js"></script>
  <script src="../assets/js/auth.js"></script>
  <script src="../assets/js/auth-check.js"></script>
  
  <!-- Avatar modules -->
  <script src="../assets/js/avatar/AudioPlayer.js"></script>
  <script src="../assets/js/avatar/LipSyncVisemes.js"></script>
  <script src="../assets/js/avatar/WebGLProvider.js"></script>
  <!--<script src="../assets/js/avatar/AvatarManager.js"></script>-->
  <script src="../assets/js/avatar/AvatarManager.js"></script>
    
    <!-- Virtual Human API (MUST load before controller) -->
    <script src="../assets/js/virtual-human-api.js"></script>

    <!-- NOTE: virtual-human-controller.js is NOT loaded here because
         classroom.html has its own VH system in #vh-root with GPUStreaming.
         Loading it would create duplicate overlays and toggle conflicts. -->
  
  <!-- TTS module -->
  <script src="../assets/js/tts.js"></script>

  <!-- Classroom Session API -->
  <script src="../assets/js/classroom-session.js"></script>

  <!-- Digital Desk Phase 2-4: Proctor, Vision AI, GPU Streaming, Lip Sync -->
  <script src="../assets/js/proctor-controller.js"></script>
  <script src="../assets/js/vision-ai.js"></script>
  <script src="../assets/js/gpu-streaming.js"></script>
  <script src="../assets/js/lip-sync-controller.js"></script>
</head>
<body class="classroom-body">
  <!-- APP SHELL CONTAINER -->
  <div class="classroom-app">

    <!-- HEADER - Fixed top bar -->
    <header class="classroom-header">
      <div class="classroom-header__brand">
        <span class="classroom-header__logo">
          <i class="fas fa-chalkboard-teacher"></i> PMERIT
        </span>
        <span class="classroom-header__title" id="lesson-title">Loading course...</span>
      </div>

      <!-- Proctor Status (Center) -->
      <div class="classroom-header__center">
        <div class="proctor-status off" id="proctor-status">
          <span class="status-dot"></span>
          <span class="status-text">Proctor: Off</span>
        </div>
      </div>

      <nav class="classroom-header__nav">
        <a href="../dashboard.html" class="classroom-header__nav-link">
          <i class="fas fa-home"></i> <span>Dashboard</span>
        </a>
        <a href="../courses.html" class="classroom-header__nav-link">
          <i class="fas fa-book"></i> <span>Courses</span>
        </a>
        <span class="classroom-header__user" id="user-display">
          <i class="fas fa-user"></i> User
        </span>
      </nav>
    </header>

    <!-- MAIN CONTENT - 3 Column Layout -->
    <div class="classroom-main">

      <!-- LEFT PANEL: Tabbed (Outline | Notes | Resources) -->
      <aside class="classroom-panel--left">
        <div class="panel-tabs">
          <button class="panel-tab active" data-tab="outline">
            <i class="fas fa-list"></i> Outline
          </button>
          <button class="panel-tab" data-tab="notes">
            <i class="fas fa-sticky-note"></i> Notes
          </button>
          <button class="panel-tab" data-tab="resources">
            <i class="fas fa-folder-open"></i> Resources
          </button>
        </div>

        <div class="panel-content">
          <!-- Outline Tab -->
          <div class="tab-pane active" id="tab-outline">
            <div id="outline-container">
              <!-- Course modules and lessons rendered here -->
            </div>
          </div>

          <!-- Notes Tab -->
          <div class="tab-pane" id="tab-notes">
            <textarea
              id="notes-text"
              class="notes-textarea"
              placeholder="Write your notes here..."
            ></textarea>
            <button id="save-notes" class="btn btn--secondary" style="width: 100%; margin-top: 12px;">
              <i class="fas fa-save"></i> Save Notes
            </button>
          </div>

          <!-- Resources Tab -->
          <div class="tab-pane" id="tab-resources">
            <input
              type="file"
              id="file-upload"
              accept=".pdf,.doc,.docx,.txt,.png,.jpg,.jpeg"
              multiple
              style="display: none;"
            >
            <button class="btn btn--secondary" style="width: 100%; margin-bottom: 12px;" onclick="document.getElementById('file-upload').click()">
              <i class="fas fa-upload"></i> Upload File
            </button>
            <div id="resources-container" class="resources-list">
              <!-- Uploaded resources appear here -->
            </div>
          </div>
        </div>
      </aside>

      <!-- CENTER PANEL: Content Stage -->
      <main class="classroom-panel--center">
        <!-- Content Header -->
        <div class="content-stage__header">
          <div class="content-stage__lesson-title" id="current-lesson-title">Select a lesson to begin</div>
          <div class="content-stage__actions">
            <button class="btn btn--secondary" id="vh-toggle" title="Toggle Virtual Human">
              <i class="fas fa-robot"></i>
            </button>
            <button class="btn btn--danger" id="end-class">
              <i class="fas fa-door-open"></i> End Class
            </button>
          </div>
        </div>

        <!-- Scrollable Content Viewport -->
        <div class="content-stage__viewport">
          <div class="content-player" id="player-area">
            <!-- Lesson content rendered here -->
            <div style="display: flex; align-items: center; justify-content: center; height: 100%; color: var(--classroom-text-muted);">
              <div style="text-align: center;">
                <i class="fas fa-play-circle" style="font-size: 64px; margin-bottom: 16px; opacity: 0.5;"></i>
                <p>Select a lesson from the outline to begin</p>
              </div>
            </div>
          </div>
        </div>

        <!-- Playback Controls Bar -->
        <div class="playback-controls">
          <button id="prev-lesson-btn" class="playback-btn" disabled>
            <i class="fas fa-step-backward"></i> Previous
          </button>
          <button id="pause-lesson-btn" class="playback-btn">
            <i class="fas fa-pause"></i> Pause
          </button>
          <div class="progress-bar-container">
            <div class="progress-bar-label">
              <span>Progress</span>
              <span id="progress-percent">0%</span>
            </div>
            <div class="progress-bar">
              <div class="progress-bar__fill" id="progress-bar" style="width: 0%;"></div>
            </div>
          </div>
          <button id="bookmark-btn" class="playback-btn">
            <i class="fas fa-bookmark"></i> Bookmark
          </button>
          <button id="next-lesson-btn" class="playback-btn playback-btn--primary" disabled>
            Next <i class="fas fa-step-forward"></i>
          </button>
        </div>
      </main>

      <!-- RIGHT PANEL: AI Tutor Chat -->
      <aside class="classroom-panel--right">
        <div class="chat-header">
          <span class="chat-header__title">
            <i class="fas fa-robot"></i> AI Tutor
          </span>
          <div class="chat-stats">
            <span class="chat-stat" title="Hand Raises">
              <i class="fas fa-hand-paper"></i>
              <span id="stat-hand-raises">0</span>
            </span>
            <span class="chat-stat" title="Questions">
              <i class="fas fa-question-circle"></i>
              <span id="stat-questions">0</span>
            </span>
          </div>
        </div>

        <button id="raise-hand-btn" class="raise-hand-btn">
          <i class="fas fa-hand-paper"></i> Raise Hand
        </button>

        <div class="chat-messages" id="chat-messages">
          <!-- Chat messages appear here -->
        </div>

        <form class="chat-form" id="chat-form">
          <input
            type="text"
            id="chat-input"
            class="chat-input"
            placeholder="Ask your AI tutor..."
            required
          >
          <button type="submit" class="chat-submit-btn">Send</button>
        </form>
      </aside>

    </div><!-- /.classroom-main -->

  </div><!-- /.classroom-app -->

  <!-- AVATAR PIP (Picture-in-Picture Widget) -->
  <div id="vh-root" class="avatar-pip hidden" aria-hidden="true">
    <div class="avatar-pip__header" id="widget-drag-handle">
      <span class="avatar-pip__title"><i class="fas fa-robot"></i> AI Tutor</span>
      <div class="avatar-pip__controls">
        <button class="avatar-pip__btn" id="widget-minimize" title="Minimize">
          <i class="fas fa-minus"></i>
        </button>
        <button class="avatar-pip__btn" id="widget-close" title="Hide">
          <i class="fas fa-times"></i>
        </button>
      </div>
    </div>
    <div class="avatar-pip__stage" id="avatar-frame">
      <div class="avatar-pip__live-badge" id="avatar-live-badge" style="display: none;">
        <span class="avatar-pip__live-dot"></span>
        <span>LIVE</span>
      </div>
      <canvas class="avatar-pip__canvas" id="vh-canvas"></canvas>
      <div class="avatar-pip__fallback" id="avatar-fallback">
        <i class="fas fa-user-graduate"></i>
      </div>
      <div class="avatar-pip__captions" id="vh-captions" aria-live="polite"></div>
    </div>
    <div class="avatar-pip__footer">
      <span class="avatar-pip__status" id="vh-status-text">Ready</span>
    </div>
  </div>

  <script>
    (function () {
      'use strict';

      // Parse courseId and lessonId from URL
      const urlParams = new URLSearchParams(window.location.search);
      const courseId = urlParams.get('courseId') || urlParams.get('course_id');
      const lessonId = urlParams.get('lessonId') || urlParams.get('lesson_id');

      // State management
      const state = {
        courseId: courseId,
        lessonId: lessonId,
        courseData: null,
        currentLesson: null,
        lessonNavigation: null,
        modules: [],
        notes: { content: "", timestamp: null },
        resources: [],
        avatarManager: null,
        gpuStreaming: null,
        sessionStart: Date.now(),
        chatMessages: []
      };

      // Expose state for debugging
      window.classroomState = state;

      // DOM elements
      const dom = {
        lessonTitle: document.getElementById('lesson-title'),
        outlineContainer: document.getElementById('outline-container'),
        notesText: document.getElementById('notes-text'),
        saveNotesBtn: document.getElementById('save-notes'),
        resourcesContainer: document.getElementById('resources-container'),
        fileUpload: document.getElementById('file-upload'),
        endClassBtn: document.getElementById('end-class'),
        chatMessages: document.getElementById('chat-messages'),
        chatForm: document.getElementById('chat-form'),
        chatInput: document.getElementById('chat-input'),
        vhToggle: document.getElementById('vh-toggle'),
        vhContainer: document.getElementById('vh-root'),
        userDisplay: document.getElementById('user-display'),
        playerArea: document.getElementById('player-area'),
        // New controls
        raiseHandBtn: document.getElementById('raise-hand-btn'),
        prevLessonBtn: document.getElementById('prev-lesson-btn'),
        nextLessonBtn: document.getElementById('next-lesson-btn'),
        pauseBtn: document.getElementById('pause-lesson-btn'),
        bookmarkBtn: document.getElementById('bookmark-btn'),
        progressBar: document.getElementById('progress-bar'),
        progressPercent: document.getElementById('progress-percent'),
        statHandRaises: document.getElementById('stat-hand-raises'),
        statQuestions: document.getElementById('stat-questions'),
        // Avatar frame elements (Digital Desk)
        avatarFrame: document.getElementById('avatar-frame'),
        avatarDropZone: document.getElementById('avatar-drop-zone'),
        avatarLiveBadge: document.getElementById('avatar-live-badge'),
        avatarFallback: document.getElementById('avatar-fallback'),
        bandwidthToggle: document.getElementById('bandwidth-toggle'),
        qaRaiseHand: document.getElementById('qa-raise-hand'),
        qaSubmitWork: document.getElementById('qa-submit-work'),
        qaAskHint: document.getElementById('qa-ask-hint'),
        proctorStatus: document.getElementById('proctor-status')
      };

      // Initialize
      async function init() {
        console.log('üéì Initializing classroom for course:', courseId);

        // Validate course ID
        if (!courseId) {
          showError('No course specified. Please select a course from your dashboard.');
          return;
        }

        // Set user display
        const user = window.AUTH?.getCurrentUser();
        if (user) {
          const displayName = user.firstName || user.email?.split('@')[0] || 'Student';
          dom.userDisplay.textContent = displayName;
        }

        // Load saved VH preference, defaulting to true (enabled)
        const savedPreference = localStorage.getItem('pmerit_vh_enabled');
        const vhEnabled = savedPreference === 'false' ? false : true;
        updateVHToggle(vhEnabled);

        bindEvents();

        // Start classroom session via API
        try {
          dom.lessonTitle.textContent = 'Starting session...';
          const session = await window.ClassroomSession.startSession(courseId, lessonId);

          if (session.resumed) {
            addChatMessage('ai', `Welcome back! Resuming your session for "${session.course.title}".`);
          } else {
            addChatMessage('ai', `Welcome to "${session.course.title}"! I'm your AI tutor. Feel free to ask questions anytime.`);
          }

          state.courseData = session.course;
          dom.lessonTitle.textContent = session.course.title;

          // Load course modules and lessons
          await loadCourseModules();

        } catch (error) {
          console.error('Failed to start session:', error);
          // Fallback to demo mode
          addChatMessage('ai', 'Hello! I\'m your AI tutor. How can I help you today?');
          await loadCourseDataFallback();
        }

        loadUserNotes();
        renderOutline();

        // Initialize avatar manager
        await initAvatarManager(vhEnabled);

        // Initialize GPU Streaming for tiered avatar (Phase 4)
        state.gpuStreaming = await initGPUStreaming();

        console.log('‚úÖ Classroom initialized');
        console.log('üéÆ Digital Desk modules loaded: ProctorController, VisionAI, GPUStreaming');
      }

      // Show error message
      function showError(message) {
        dom.lessonTitle.textContent = 'Error';
        dom.playerArea.innerHTML = `
          <div style="text-align: center; padding: 40px; color: var(--color-error, #C4314B);">
            <i class="fas fa-exclamation-circle" style="font-size: 48px; margin-bottom: 16px;"></i>
            <p>${message}</p>
            <a href="../dashboard.html" class="btn" style="margin-top: 20px;">
              <i class="fas fa-home"></i> Return to Dashboard
            </a>
          </div>
        `;
      }

      // Load course modules from API
      async function loadCourseModules() {
        try {
          const modules = await window.ClassroomSession.getCourseModules(courseId);
          state.modules = modules;
          renderOutline();

          // Load first lesson if no specific lesson requested
          if (!lessonId && modules.length > 0 && modules[0].lessons?.length > 0) {
            const firstLesson = modules[0].lessons[0];
            await loadLesson(firstLesson.lesson_id);
          } else if (lessonId) {
            await loadLesson(lessonId);
          }
        } catch (error) {
          console.error('Failed to load modules:', error);
        }
      }

      // Load lesson content
      async function loadLesson(lessonId) {
        try {
          const data = await window.ClassroomSession.getLessonDetails(lessonId);
          state.currentLesson = data.lesson;
          state.lessonId = lessonId;

          // Update UI
          dom.lessonTitle.textContent = `${state.courseData?.title || 'Course'} - ${data.lesson.title}`;

          // Render lesson content
          renderLessonContent(data.lesson);

          // Update navigation buttons
          updateNavigation(data.navigation);

          // Update session with current lesson
          await window.ClassroomSession.updateProgress({
            lesson_id: lessonId
          });

          // Reset progress bar for new lesson
          updateProgressBar(0);

          // Update outline to show active lesson
          renderOutline();

          // Update stats
          updateStats();

        } catch (error) {
          console.error('Failed to load lesson:', error);
        }
      }

      // Render lesson content in player area
      function renderLessonContent(lesson) {
        const typeIcon = {
          video: 'fa-play-circle',
          reading: 'fa-book-open',
          interactive: 'fa-hand-pointer',
          quiz: 'fa-question-circle',
          project: 'fa-project-diagram',
          discussion: 'fa-comments'
        };

        const icon = typeIcon[lesson.lesson_type] || 'fa-file';
        const duration = lesson.estimated_duration_minutes
          ? `${lesson.estimated_duration_minutes} min`
          : '';

        let contentHTML = `
          <div class="lesson-header" style="margin-bottom: 20px;">
            <h3><i class="fas ${icon}"></i> ${lesson.title}</h3>
            <div class="lesson-meta" style="color: var(--text-secondary); font-size: 0.9rem; margin-top: 8px;">
              <span><i class="fas fa-clock"></i> ${duration}</span>
              <span style="margin-left: 16px;"><i class="fas fa-layer-group"></i> ${lesson.module_title || 'Module'}</span>
            </div>
          </div>
        `;

        // Render based on lesson type
        if (lesson.lesson_type === 'video' && lesson.content_url) {
          contentHTML += `
            <div class="video-container" style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; border-radius: 8px;">
              <iframe src="${lesson.content_url}" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border: none;" allowfullscreen></iframe>
            </div>
          `;
        } else if (lesson.transcript) {
          contentHTML += `
            <div class="lesson-content" style="background: var(--bg-elevated); padding: 20px; border-radius: 8px; max-height: 400px; overflow-y: auto;">
              ${lesson.transcript}
            </div>
          `;
        } else {
          contentHTML += `
            <div class="lesson-placeholder" style="text-align: center; padding: 60px; background: var(--bg-elevated); border-radius: 8px;">
              <i class="fas ${icon}" style="font-size: 64px; color: var(--color-secondary); margin-bottom: 16px;"></i>
              <p>Lesson content is being prepared.</p>
              <p style="color: var(--text-secondary); margin-top: 8px;">Use the AI tutor chat to ask questions about this topic.</p>
            </div>
          `;
        }

        dom.playerArea.innerHTML = contentHTML;
      }

      // Fallback to demo data if API fails
      async function loadCourseDataFallback() {
        const demoData = {
          id: courseId || 'demo-course',
          title: "Introduction to PMERIT Classroom",
          modules: [
            {
              id: 'mod-1',
              title: "Module 1: Getting Started",
              lessons: [
                { lesson_id: 'les-1', title: "Welcome to PMERIT", lesson_type: "video", estimated_duration_minutes: 3 },
                { lesson_id: 'les-2', title: "How to Use This Platform", lesson_type: "video", estimated_duration_minutes: 5 }
              ]
            },
            {
              id: 'mod-2',
              title: "Module 2: Core Concepts",
              lessons: [
                { lesson_id: 'les-3', title: "Basic Principles", lesson_type: "video", estimated_duration_minutes: 7 },
                { lesson_id: 'les-4', title: "Advanced Techniques", lesson_type: "reading", estimated_duration_minutes: 10 }
              ]
            }
          ]
        };

        state.courseData = demoData;
        state.modules = demoData.modules;
        dom.lessonTitle.textContent = demoData.title;
      }

      // Initialize Avatar Manager
      // NOTE: In classroom, GPUStreaming handles WebGL rendering.
      // AvatarManager is only used for TTS/audio, NOT for canvas rendering.
      async function initAvatarManager(enabled) {
        try {
          if (!window.AvatarManager) {
            console.warn('AvatarManager not loaded - using GPUStreaming only');
            updateVHStatus('Virtual Human is ready');
            return;
          }

          // Create AvatarManager but DISABLE its WebGL provider
          // (GPUStreaming handles all canvas rendering)
          state.avatarManager = new window.AvatarManager({
            canvasId: null, // Don't use canvas - GPUStreaming handles it
            captionsId: 'vh-captions',
            enabled: false, // Disable WebGL provider
            apiBaseUrl: window.CONFIG?.API_BASE_URL || 'https://pmerit-api-worker.peoplemerit.workers.dev',
            onSpeakStart: () => {
              dom.vhContainer.classList.add('speaking');
              dom.avatarFrame?.classList.add('speaking');
            },
            onSpeakEnd: () => {
              dom.vhContainer.classList.remove('speaking');
              dom.avatarFrame?.classList.remove('speaking');
            },
            onError: null
          });

          // Initialize for TTS only (no WebGL)
          await state.avatarManager.init();
          console.log('AvatarManager initialized for TTS only (GPUStreaming handles rendering)');

          if (enabled) {
            updateVHStatus('Virtual Human is ready');
            const userTier = getUserTier();
            setAvatarTier(userTier);
          } else {
            dom.vhContainer.classList.add('audio-only');
            setAvatarTier('fallback');
            updateVHStatus('Virtual Human disabled');
          }
        } catch (error) {
          console.warn('Avatar init graceful fallback:', error.message);
          updateVHStatus('Ready (basic mode)');
        }
      }

      // Helper to update VH status text
      function updateVHStatus(text) {
        const statusText = document.getElementById('vh-status-text');
        if (statusText) {
          statusText.textContent = text;
        }
      }

      // Get user subscription tier
      function getUserTier() {
        // Check user subscription from localStorage or API
        const user = window.AUTH?.getCurrentUser();
        const tier = user?.subscription_tier || localStorage.getItem('pmerit_user_tier') || 'standard';
        return tier; // 'premium', 'standard', 'free', or 'fallback'
      }

      // =========================================
      // DIGITAL DESK MODULES (Phase 2-4)
      // =========================================

      // Initialize GPU Streaming for tiered avatar rendering
      async function initGPUStreaming() {
        if (!window.GPUStreaming) {
          console.warn('GPUStreaming module not loaded - using fallback');
          showAvatarError({ message: 'WebGL not available' });
          return null;
        }

        try {
          const gpuStreaming = await window.createGPUStreaming(dom.avatarFrame, {
            idleTimeout: 300000, // 5 minutes
            maxSessionDuration: 3600000 // 1 hour
          });

          // Listen for tier changes
          gpuStreaming.onTierChange((newTier, previousTier) => {
            console.log(`Avatar tier changed: ${previousTier} -> ${newTier}`);
            setAvatarTier(newTier);
          });

          // Listen for connection changes
          gpuStreaming.onConnectionChange((isConnected) => {
            if (isConnected) {
              console.log('GPU streaming connected');
            } else {
              console.log('GPU streaming disconnected');
            }
          });

          // Listen for cost updates
          gpuStreaming.onCostUpdate((costCents) => {
            console.log(`Session cost: $${(costCents / 100).toFixed(2)}`);
          });

          // Listen for errors - SILENT FALLBACK
          gpuStreaming.onError((type, message) => {
            console.warn(`GPU streaming error (${type}):`, message);
            // Silent fallback - no scary error screens
            showAvatarError({ message });
          });

          // Start streaming to load the avatar
          // Check if VH is enabled before starting
          const vhEnabled = localStorage.getItem('pmerit_vh_enabled') !== 'false';
          if (vhEnabled) {
            console.log('üé¨ Starting avatar streaming...');
            await gpuStreaming.startStreaming();
            updateVHStatus('Ready');
          }

          return gpuStreaming;
        } catch (error) {
          console.error('Failed to initialize GPU streaming:', error);
          // Silent fallback
          showAvatarError(error);
          return null;
        }
      }

      // Initialize Vision AI for proctored exams
      async function initVisionAI() {
        if (!window.VisionAI) {
          console.warn('VisionAI module not loaded');
          return null;
        }

        // Only initialize when entering an exam
        return null; // Will be initialized on-demand
      }

      // Start a proctored exam session
      async function startProctoredExam(examData) {
        if (!window.ProctorController) {
          console.error('ProctorController module not loaded');
          return false;
        }

        try {
          // Create proctor session
          const proctor = await window.createProctorSession(examData, {
            maxViolations: 3,
            enableVisionAI: true,
            timerWarningMinutes: 5,
            timerCriticalMinutes: 1,
            onViolation: (violation) => {
              console.warn('Proctor violation:', violation);
            },
            onExamEnd: (result) => {
              console.log('Exam ended:', result);
              endProctoredExam();
            }
          });

          // Initialize Vision AI if enabled
          if (examData.enableVisionAI !== false) {
            const visionAI = await window.createVisionAI('vision-ai-video', {
              faceDetectionInterval: 1000,
              gazeThreshold: 0.3,
              confidenceThreshold: 0.7
            });

            if (visionAI) {
              // Connect Vision AI to Proctor Controller
              proctor.setVisionAI(visionAI);

              // Start detection
              await visionAI.startDetection();
            }
          }

          // Enter proctor mode
          proctor.enterProctorMode();

          return proctor;

        } catch (error) {
          console.error('Failed to start proctored exam:', error);
          return false;
        }
      }

      // End proctored exam
      async function endProctoredExam() {
        if (window.proctorController) {
          // Vision AI cleanup
          if (window.proctorController.visionAI) {
            window.proctorController.visionAI.destroy();
          }

          // Exit proctor mode
          window.proctorController.exitProctorMode();
        }
      }

      // Expose functions globally for testing
      window.startProctoredExam = startProctoredExam;
      window.endProctoredExam = endProctoredExam;

      // Set avatar tier styling
      function setAvatarTier(tier) {
        if (!dom.avatarFrame) return;

        // Remove all tier classes
        dom.avatarFrame.classList.remove('tier-free', 'tier-standard', 'tier-premium', 'tier-fallback');

        // Add new tier class
        dom.avatarFrame.classList.add(`tier-${tier}`);

        // Update live badge
        if (dom.avatarLiveBadge) {
          if (tier === 'premium') {
            dom.avatarLiveBadge.innerHTML = '<span class="live-dot"></span> LIVE HD';
            dom.avatarLiveBadge.classList.add('premium', 'hd');
            dom.avatarLiveBadge.style.display = 'flex';
          } else if (tier === 'standard') {
            dom.avatarLiveBadge.innerHTML = '<span class="live-dot"></span> LIVE';
            dom.avatarLiveBadge.classList.remove('premium', 'hd');
            dom.avatarLiveBadge.style.display = 'flex';
          } else {
            dom.avatarLiveBadge.style.display = 'none';
          }
        }

        // Update fallback visibility
        if (dom.avatarFallback) {
          dom.avatarFallback.style.display = tier === 'fallback' ? 'flex' : 'none';
        }

        console.log(`Avatar tier set to: ${tier}`);
      }

      // Bind event handlers
      function bindEvents() {
        dom.saveNotesBtn.addEventListener('click', saveNotes);
        dom.fileUpload.addEventListener('change', handleFileUpload);
        dom.endClassBtn.addEventListener('click', endClass);
        dom.chatForm.addEventListener('submit', handleChatSubmit);
        dom.vhToggle.addEventListener('click', toggleVirtualHuman);

        // New control handlers
        dom.raiseHandBtn.addEventListener('click', handleRaiseHand);
        dom.prevLessonBtn.addEventListener('click', handlePrevLesson);
        dom.nextLessonBtn.addEventListener('click', handleNextLesson);
        dom.pauseBtn.addEventListener('click', handlePauseResume);
        dom.bookmarkBtn.addEventListener('click', handleBookmark);

        // Tab switching for left panel
        setupTabSwitching();

        // Widget controls
        setupWidgetControls();
      }

      // =========================================
      // TAB SWITCHING (Left Panel)
      // =========================================
      function setupTabSwitching() {
        const tabs = document.querySelectorAll('.panel-tab');
        const panes = document.querySelectorAll('.tab-pane');

        tabs.forEach(tab => {
          tab.addEventListener('click', () => {
            const tabId = tab.getAttribute('data-tab');

            // Update tab active states
            tabs.forEach(t => t.classList.remove('active'));
            tab.classList.add('active');

            // Update pane visibility
            panes.forEach(pane => {
              pane.classList.remove('active');
              if (pane.id === `tab-${tabId}`) {
                pane.classList.add('active');
              }
            });
          });
        });
      }

      // =========================================
      // FLOATING WIDGET CONTROLS
      // =========================================
      function setupWidgetControls() {
        const widget = document.getElementById('vh-root');
        const dragHandle = document.getElementById('widget-drag-handle');
        const minimizeBtn = document.getElementById('widget-minimize');
        const closeBtn = document.getElementById('widget-close');

        if (!widget || !dragHandle) return;

        // Make widget draggable
        let isDragging = false;
        let startX, startY, startLeft, startTop;

        dragHandle.addEventListener('mousedown', (e) => {
          if (e.target.closest('.widget-btn')) return; // Don't drag when clicking buttons
          isDragging = true;
          widget.classList.add('dragging');
          startX = e.clientX;
          startY = e.clientY;
          const rect = widget.getBoundingClientRect();
          startLeft = rect.left;
          startTop = rect.top;
          e.preventDefault();
        });

        document.addEventListener('mousemove', (e) => {
          if (!isDragging) return;
          const dx = e.clientX - startX;
          const dy = e.clientY - startY;

          // Calculate new position
          let newLeft = startLeft + dx;
          let newTop = startTop + dy;

          // Keep within viewport
          const maxLeft = window.innerWidth - widget.offsetWidth - 10;
          const maxTop = window.innerHeight - widget.offsetHeight - 10;
          newLeft = Math.max(10, Math.min(newLeft, maxLeft));
          newTop = Math.max(10, Math.min(newTop, maxTop));

          widget.style.left = newLeft + 'px';
          widget.style.top = newTop + 'px';
          widget.style.right = 'auto'; // Override CSS right positioning
        });

        document.addEventListener('mouseup', () => {
          if (isDragging) {
            isDragging = false;
            widget.classList.remove('dragging');
            // Save position to localStorage
            localStorage.setItem('pmerit_widget_pos', JSON.stringify({
              left: widget.style.left,
              top: widget.style.top
            }));
          }
        });

        // Touch support for mobile
        dragHandle.addEventListener('touchstart', (e) => {
          if (e.target.closest('.widget-btn')) return;
          const touch = e.touches[0];
          isDragging = true;
          startX = touch.clientX;
          startY = touch.clientY;
          const rect = widget.getBoundingClientRect();
          startLeft = rect.left;
          startTop = rect.top;
        }, { passive: true });

        document.addEventListener('touchmove', (e) => {
          if (!isDragging) return;
          const touch = e.touches[0];
          const dx = touch.clientX - startX;
          const dy = touch.clientY - startY;
          let newLeft = startLeft + dx;
          let newTop = startTop + dy;
          const maxLeft = window.innerWidth - widget.offsetWidth - 10;
          const maxTop = window.innerHeight - widget.offsetHeight - 10;
          newLeft = Math.max(10, Math.min(newLeft, maxLeft));
          newTop = Math.max(10, Math.min(newTop, maxTop));
          widget.style.left = newLeft + 'px';
          widget.style.top = newTop + 'px';
          widget.style.right = 'auto';
        }, { passive: true });

        document.addEventListener('touchend', () => {
          isDragging = false;
        });

        // Restore saved position
        const savedPos = localStorage.getItem('pmerit_widget_pos');
        if (savedPos) {
          try {
            const pos = JSON.parse(savedPos);
            widget.style.left = pos.left;
            widget.style.top = pos.top;
            widget.style.right = 'auto';
          } catch (e) { /* ignore */ }
        }

        // Minimize button
        if (minimizeBtn) {
          minimizeBtn.addEventListener('click', () => {
            widget.classList.toggle('minimized');
            const icon = minimizeBtn.querySelector('i');
            if (widget.classList.contains('minimized')) {
              icon.className = 'fas fa-plus';
              minimizeBtn.title = 'Expand';
            } else {
              icon.className = 'fas fa-minus';
              minimizeBtn.title = 'Minimize';
            }
          });
        }

        // Close button (hides widget, toggles VH off)
        if (closeBtn) {
          closeBtn.addEventListener('click', () => {
            toggleVirtualHuman(); // This will hide the widget
          });
        }
      }

      // Handle Raise Hand button
      async function handleRaiseHand() {
        // Focus chat input for question
        dom.chatInput.focus();
        dom.chatInput.placeholder = 'Type your question here...';

        // Visual feedback
        dom.raiseHandBtn.innerHTML = '<i class="fas fa-hand-paper"></i> Hand Raised!';
        dom.raiseHandBtn.style.background = 'var(--color-success, #3A7F5C)';

        // Log interaction
        if (window.ClassroomSession?.hasActiveSession()) {
          await window.ClassroomSession.logInteraction('hand_raise', {
            position: { lessonId: state.lessonId }
          });
          updateStats();
        }

        // Reset button after 3 seconds
        setTimeout(() => {
          dom.raiseHandBtn.innerHTML = '<i class="fas fa-hand-paper"></i> Raise Hand';
          dom.raiseHandBtn.style.background = 'var(--color-secondary, #4AA4B9)';
          dom.chatInput.placeholder = 'Ask your AI tutor...';
        }, 3000);
      }

      // Handle Previous Lesson
      async function handlePrevLesson() {
        if (state.lessonNavigation?.prev_lesson_id) {
          await loadLesson(state.lessonNavigation.prev_lesson_id);
        }
      }

      // Handle Next Lesson
      async function handleNextLesson() {
        if (state.lessonNavigation?.next_lesson_id) {
          // Mark current lesson as completed before moving to next
          if (state.lessonId) {
            markLessonCompleted(state.lessonId);
          }
          await loadLesson(state.lessonNavigation.next_lesson_id);
        }
      }

      // Handle Pause/Resume
      let isPaused = false;
      function handlePauseResume() {
        isPaused = !isPaused;

        if (isPaused) {
          dom.pauseBtn.innerHTML = '<i class="fas fa-play"></i> Resume';
          // Log pause
          if (window.ClassroomSession?.hasActiveSession()) {
            window.ClassroomSession.logInteraction('pause', {
              position: { lessonId: state.lessonId }
            });
          }
        } else {
          dom.pauseBtn.innerHTML = '<i class="fas fa-pause"></i> Pause';
          // Log resume
          if (window.ClassroomSession?.hasActiveSession()) {
            window.ClassroomSession.logInteraction('resume', {
              position: { lessonId: state.lessonId }
            });
          }
        }
      }

      // Handle Bookmark
      async function handleBookmark() {
        // Save bookmark
        const bookmarks = JSON.parse(localStorage.getItem(`pmerit_bookmarks_${courseId}`) || '[]');
        const bookmark = {
          lessonId: state.lessonId,
          lessonTitle: state.currentLesson?.title,
          timestamp: new Date().toISOString()
        };
        bookmarks.push(bookmark);
        localStorage.setItem(`pmerit_bookmarks_${courseId}`, JSON.stringify(bookmarks));

        // Log interaction
        if (window.ClassroomSession?.hasActiveSession()) {
          await window.ClassroomSession.logInteraction('bookmark', {
            position: { lessonId: state.lessonId }
          });
        }

        // Visual feedback
        dom.bookmarkBtn.innerHTML = '<i class="fas fa-bookmark"></i> Saved!';
        dom.bookmarkBtn.style.color = 'var(--color-success, #3A7F5C)';
        setTimeout(() => {
          dom.bookmarkBtn.innerHTML = '<i class="fas fa-bookmark"></i> Bookmark';
          dom.bookmarkBtn.style.color = '';
        }, 2000);
      }

      // Update session stats display
      function updateStats() {
        const sessionState = window.ClassroomSession?.getState() || {};
        dom.statHandRaises.textContent = sessionState.handRaises || 0;
        dom.statQuestions.textContent = sessionState.questionsAsked || 0;
      }

      // Update progress bar
      function updateProgressBar(percent) {
        dom.progressBar.style.width = `${percent}%`;
        dom.progressPercent.textContent = `${Math.round(percent)}%`;
      }

      // Update navigation buttons
      function updateNavigation(navigation) {
        state.lessonNavigation = navigation;
        dom.prevLessonBtn.disabled = !navigation?.prev_lesson_id;
        dom.nextLessonBtn.disabled = !navigation?.next_lesson_id;
      }

      // Toggle Virtual Human
      async function toggleVirtualHuman() {
        const currentlyEnabled = !dom.vhToggle.classList.contains('off');
        const newState = !currentlyEnabled;

        console.log('VH Toggle:', currentlyEnabled, '->', newState);

        updateVHToggle(newState);
        localStorage.setItem('pmerit_vh_enabled', newState.toString());

        if (state.avatarManager) {
          state.avatarManager.setEnabled(newState);
        }

        if (newState) {
          // Turning ON - show VH and initialize if needed
          dom.vhContainer.classList.remove('audio-only');
          updateVHStatus('Initializing...');

          // Initialize avatar manager if not already done
          if (state.avatarManager && !state.avatarManager.state?.initialized) {
            initAvatarManager(true);
          } else if (!state.avatarManager) {
            initAvatarManager(true);
          } else {
            // Already initialized - just update status
            if (state.avatarManager.state?.provider) {
              updateVHStatus('Virtual Human is ready');
            } else {
              updateVHStatus('Ready (audio mode)');
            }
          }

          // Also init/start GPU streaming if available
          if (window.GPUStreaming) {
            if (!state.gpuStreaming) {
              state.gpuStreaming = await initGPUStreaming();
            } else {
              // GPUStreaming exists but may not be streaming
              console.log('üé¨ Starting avatar streaming...');
              await state.gpuStreaming.startStreaming();
              updateVHStatus('Virtual Human is ready');
            }
          }
        } else {
          // Turning OFF - hide VH and stop streaming
          dom.vhContainer.classList.add('audio-only');
          updateVHStatus('Virtual Human disabled');
          if (state.gpuStreaming) {
            state.gpuStreaming.stopStreaming();
          }
        }
      }

      // Update VH toggle UI
      function updateVHToggle(enabled) {
        if (enabled) {
          dom.vhToggle.classList.remove('off');
          // Show vh-root container (avatar-pip)
          dom.vhContainer.classList.remove('hidden');
          dom.vhContainer.setAttribute('aria-hidden', 'false');
        } else {
          dom.vhToggle.classList.add('off');
          // Hide vh-root container (avatar-pip)
          dom.vhContainer.classList.add('hidden');
          dom.vhContainer.setAttribute('aria-hidden', 'true');
        }
      }

      // Load user notes
      function loadUserNotes() {
        const noteKey = `pmerit_notes_${courseId}`;
        const savedNotes = localStorage.getItem(noteKey);
        if (savedNotes) {
          state.notes = JSON.parse(savedNotes);
          dom.notesText.value = state.notes.content || "";
        }
      }

      // Render course outline with completion indicators
      function renderOutline() {
        if (!state.modules || state.modules.length === 0) {
          dom.outlineContainer.innerHTML = '<p style="color: var(--classroom-text-muted);">No modules available.</p>';
          return;
        }

        // Get completed lessons from localStorage
        const completedLessons = JSON.parse(localStorage.getItem(`pmerit_completed_${state.courseId}`) || '[]');

        let outlineHTML = '';
        state.modules.forEach((module, moduleIndex) => {
          // Count completed lessons in this module
          const moduleLessons = module.lessons || [];
          const completedInModule = moduleLessons.filter(l => completedLessons.includes(l.lesson_id)).length;
          const moduleComplete = moduleLessons.length > 0 && completedInModule === moduleLessons.length;
          const moduleProgress = moduleLessons.length > 0 ? Math.round((completedInModule / moduleLessons.length) * 100) : 0;

          outlineHTML += `
            <div class="outline-module">
              <div class="outline-module__header ${moduleComplete ? 'completed' : ''}">
                <i class="fas ${moduleComplete ? 'fa-folder-open' : 'fa-folder'}"></i>
                <span>${module.title}</span>
                ${moduleProgress > 0 ? `<span class="outline-module__progress">${moduleProgress}%</span>` : ''}
              </div>`;

          if (module.lessons && module.lessons.length > 0) {
            module.lessons.forEach((lesson) => {
              const isActive = state.lessonId === lesson.lesson_id;
              const isCompleted = completedLessons.includes(lesson.lesson_id);
              const icon = isCompleted ? 'fa-check-circle' :
                          lesson.lesson_type === 'video' ? 'fa-play-circle' :
                          lesson.lesson_type === 'reading' ? 'fa-book' : 'fa-file';
              const duration = lesson.estimated_duration_minutes ? `${lesson.estimated_duration_minutes}m` : '';

              outlineHTML += `
                <div class="outline-lesson ${isActive ? 'active' : ''} ${isCompleted ? 'completed' : ''}"
                     data-lesson-id="${lesson.lesson_id}"
                     onclick="window.loadLesson('${lesson.lesson_id}')">
                  <span class="outline-lesson__icon"><i class="fas ${icon}"></i></span>
                  <span class="outline-lesson__title">${lesson.title || lesson.lesson_title}</span>
                  ${duration ? `<span class="outline-lesson__duration">${duration}</span>` : ''}
                </div>
              `;
            });
          }
          outlineHTML += '</div>'; // Close outline-module
        });
        dom.outlineContainer.innerHTML = outlineHTML;
      }

      // Mark lesson as completed
      function markLessonCompleted(lessonId) {
        const completedLessons = JSON.parse(localStorage.getItem(`pmerit_completed_${state.courseId}`) || '[]');
        if (!completedLessons.includes(lessonId)) {
          completedLessons.push(lessonId);
          localStorage.setItem(`pmerit_completed_${state.courseId}`, JSON.stringify(completedLessons));
          renderOutline(); // Re-render to show checkmark
        }
      }

      // Expose for testing
      window.markLessonCompleted = markLessonCompleted;

      // Expose loadLesson globally for outline clicks
      window.loadLesson = async function(lessonId) {
        await loadLesson(lessonId);
      };

      // Save notes
      function saveNotes() {
        state.notes.content = dom.notesText.value;
        state.notes.timestamp = new Date().toISOString();
        localStorage.setItem(`pmerit_notes_${courseId}`, JSON.stringify(state.notes));

        // Log interaction
        if (window.ClassroomSession?.hasActiveSession()) {
          window.ClassroomSession.logInteraction('note', {
            position: { lessonId: state.lessonId }
          });
        }

        // Show success feedback
        const btn = dom.saveNotesBtn;
        const originalText = btn.textContent;
        btn.textContent = '‚úì Saved!';
        btn.style.backgroundColor = 'var(--color-success, #3A7F5C)';
        setTimeout(() => {
          btn.textContent = originalText;
          btn.style.backgroundColor = '';
        }, 2000);
      }

      // Handle file upload
      function handleFileUpload(event) {
        const files = Array.from(event.target.files);
        files.forEach(file => {
          state.resources.push({ name: file.name, size: file.size, type: file.type });
        });
        renderResources();
      }

      // Render resources
      function renderResources() {
        let resourcesHTML = '';
        state.resources.forEach(resource => {
          resourcesHTML += `<div class="resource-item"><strong>${resource.name}</strong> <small>(${formatFileSize(resource.size)})</small></div>`;
        });
        dom.resourcesContainer.innerHTML = resourcesHTML || '<p>No resources uploaded yet.</p>';
      }

      // Format file size
      function formatFileSize(bytes) {
        if (bytes < 1024) return bytes + ' bytes';
        else if (bytes < 1048576) return (bytes / 1024).toFixed(1) + ' KB';
        else return (bytes / 1048576).toFixed(1) + ' MB';
      }

      // Handle chat submit - uses real AI API
      async function handleChatSubmit(event) {
        event.preventDefault();
        const message = dom.chatInput.value.trim();
        if (!message) return;

        addChatMessage('user', message);
        dom.chatInput.value = '';

        // Log hand raise interaction
        const startTime = Date.now();
        if (window.ClassroomSession?.hasActiveSession()) {
          await window.ClassroomSession.raiseHand(message);
        }

        // Call AI Tutor API
        try {
          const response = await fetch(`${window.CONFIG?.API_BASE_URL || 'https://pmerit-api-worker.peoplemerit.workers.dev'}/api/v1/ai/tutor`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              messages: state.chatMessages.concat([{ role: 'user', content: message }])
            })
          });

          // Handle streaming response
          const reader = response.body.getReader();
          const decoder = new TextDecoder();
          let aiResponse = '';

          while (true) {
            const { done, value } = await reader.read();
            if (done) break;

            const chunk = decoder.decode(value, { stream: true });
            // Parse SSE data
            const lines = chunk.split('\n');
            for (const line of lines) {
              if (line.startsWith('data: ')) {
                try {
                  const data = JSON.parse(line.slice(6));
                  if (data.response) {
                    aiResponse += data.response;
                  }
                } catch (e) {
                  // Not JSON, might be raw text
                  aiResponse += line.slice(6);
                }
              }
            }
          }

          // Clean up response
          aiResponse = aiResponse.trim() || "I'm here to help! Could you please rephrase your question?";

          // Log response time
          const responseTime = Date.now() - startTime;
          if (window.ClassroomSession?.hasActiveSession()) {
            await window.ClassroomSession.logInteraction('question', {
              question: message,
              response: aiResponse,
              responseTimeMs: responseTime
            });
          }

          // Update chat history
          state.chatMessages.push({ role: 'user', content: message });
          state.chatMessages.push({ role: 'assistant', content: aiResponse });

          addChatMessage('ai', aiResponse);

          // Speak with avatar if enabled
          if (state.avatarManager?.isEnabled()) {
            await state.avatarManager.speak(aiResponse);
          }

        } catch (error) {
          console.error('AI chat error:', error);
          addChatMessage('ai', 'I apologize, but I encountered an issue. Please try again.');
        }
      }

      // Add chat message
      function addChatMessage(sender, message) {
        const messageDiv = document.createElement('div');
        messageDiv.classList.add('chat-message', `chat-message--${sender}`);
        messageDiv.textContent = message;
        dom.chatMessages.appendChild(messageDiv);
        dom.chatMessages.scrollTop = dom.chatMessages.scrollHeight;
      }

      // Show avatar error - GRACEFUL FALLBACK (no red error screens)
      function showAvatarError(error) {
        console.warn('Avatar fallback triggered:', error?.message || error);

        // Switch to fallback mode
        dom.vhContainer.classList.add('fallback');

        // Update status text with friendly message
        const statusText = document.getElementById('vh-status-text');
        if (statusText) {
          statusText.textContent = 'Audio-only mode active';
        }

        // Set fallback tier
        setAvatarTier('fallback');

        // Show non-intrusive toast notification instead of blocking error
        showToast('Low bandwidth detected. Using audio-only mode.', 'info');
      }

      // Toast notification helper
      function showToast(message, type = 'info') {
        // Remove existing toast if any
        const existingToast = document.querySelector('.classroom-toast');
        if (existingToast) {
          existingToast.remove();
        }

        const toast = document.createElement('div');
        toast.className = `classroom-toast classroom-toast--${type}`;
        toast.innerHTML = `<i class="fas fa-info-circle"></i> ${message}`;
        document.body.appendChild(toast);

        // Auto-remove after 4 seconds
        setTimeout(() => {
          toast.style.animation = 'toast-out 0.3s ease-in forwards';
          setTimeout(() => toast.remove(), 300);
        }, 4000);
      }

      // End class session
      async function endClass() {
        if (!confirm('Are you sure you want to end this class session?')) {
          return;
        }

        try {
          // End session via API
          if (window.ClassroomSession?.hasActiveSession()) {
            const notes = dom.notesText.value;
            await window.ClassroomSession.endSession(notes);
          }
        } catch (error) {
          console.error('Failed to end session:', error);
        }

        // Clean up avatar
        if (state.avatarManager) {
          state.avatarManager.dispose();
        }

        // Redirect to dashboard
        window.location.href = '../dashboard.html';
      }

      // Start initialization
      document.addEventListener('DOMContentLoaded', init);
    })();
  </script>
</body>
</html>
