<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
  <title>Classroom | PMERIT Learner Portal</title>
  <meta name="description" content="Interactive classroom with AI Tutor and Virtual Human">
  
  <!-- Google Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  
  <!-- Font Awesome -->
  <link 
    rel="stylesheet" 
    href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css"
    integrity="sha512-SnH5WK+bZxgPHs44uWIX+LLJAJ9/2PkPKZ5QiAj6Ta86w+fsb2TkcmfRyVX3pBnMFcV7oQPJkl9QevSCWr3W6A=="
    crossorigin="anonymous"
    referrerpolicy="no-referrer">
  
  <!-- PMERIT Unified Design System -->
  <link rel="stylesheet" href="../assets/css/theme-variables.css">
  <link rel="stylesheet" href="../assets/css/typography.css">
  <link rel="stylesheet" href="../assets/css/base.css">
  <link rel="stylesheet" href="../assets/css/components.css">
  <link rel="stylesheet" href="../assets/css/avatar.css">
  <link rel="stylesheet" href="../assets/css/virtual-human-overlay.css">
  <!-- Digital Desk Redesign -->
  <link rel="stylesheet" href="../assets/css/avatar-frame.css">
  <link rel="stylesheet" href="../assets/css/proctor-mode.css">

  <!-- Three.js r128 for WebGL avatar (last version with global THREE.GLTFLoader) -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
  <!-- Meshopt decoder for compressed GLB models -->
  <script src="https://cdn.jsdelivr.net/npm/meshoptimizer@0.18.1/meshopt_decoder.js"></script>
  <script>
    // Configure GLTFLoader with meshopt decoder after both are loaded
    if (typeof THREE !== 'undefined' && typeof MeshoptDecoder !== 'undefined') {
      MeshoptDecoder.ready.then(() => {
        if (THREE.GLTFLoader) {
          THREE.GLTFLoader.prototype.setMeshoptDecoder = function(decoder) {
            this.meshoptDecoder = decoder;
            return this;
          };
          console.log('âœ… MeshoptDecoder ready for GLTFLoader');
        }
      });
    }
  </script>
  
  <!-- Auth protection -->
  <script src="../assets/js/config.js"></script>
  <script src="../assets/js/auth.js"></script>
  <script src="../assets/js/auth-check.js"></script>
  
  <!-- Avatar modules -->
  <script src="../assets/js/avatar/AudioPlayer.js"></script>
  <script src="../assets/js/avatar/LipSyncVisemes.js"></script>
  <script src="../assets/js/avatar/WebGLProvider.js"></script>
  <!--<script src="../assets/js/avatar/AvatarManager.js"></script>-->
  <script src="../assets/js/avatar/AvatarManager.js"></script>
    
    <!-- Virtual Human API (MUST load before controller) -->
    <script src="../assets/js/virtual-human-api.js"></script>

    <!-- NOTE: virtual-human-controller.js is NOT loaded here because
         classroom.html has its own VH system in #vh-root with GPUStreaming.
         Loading it would create duplicate overlays and toggle conflicts. -->
  
  <!-- TTS module -->
  <script src="../assets/js/tts.js"></script>

  <!-- Classroom Session API -->
  <script src="../assets/js/classroom-session.js"></script>

  <!-- Digital Desk Phase 2-4: Proctor, Vision AI, GPU Streaming -->
  <script src="../assets/js/proctor-controller.js"></script>
  <script src="../assets/js/vision-ai.js"></script>
  <script src="../assets/js/gpu-streaming.js"></script>

  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { 
      font-family: 'Inter', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
      background-color: var(--bg-primary, #F8F9FA); 
      color: var(--text-primary, #2C2C2C); 
      line-height: 1.6; 
      overflow-x: hidden; 
    }
    
    .portal-header {
      background: linear-gradient(135deg, var(--color-primary, #2A5B8C), #1E4567);
      padding: 1rem 2rem;
      border-bottom: 2px solid var(--color-secondary, #4AA4B9);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .portal-header h1 {
      color: var(--text-inverse, #FFFFFF);
      font-size: 1.5rem;
      font-weight: 600;
    }
    
    .portal-nav {
      display: flex;
      gap: 1rem;
      align-items: center;
    }
    
    .portal-nav a {
      color: var(--text-inverse, #FFFFFF);
      text-decoration: none;
      padding: 0.5rem 1rem;
      border-radius: 6px;
      transition: background-color 0.2s;
    }
    
    .portal-nav a:hover {
      background-color: rgba(255, 255, 255, 0.15);
    }

    /* User display in header - FIX visibility */
    #user-display {
      color: #E0F7FA;
      font-weight: 500;
      padding: 0.5rem 1rem;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 20px;
      font-size: 0.9rem;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    #user-display::before {
      content: '\f007'; /* Font Awesome user icon */
      font-family: 'Font Awesome 6 Free';
      font-weight: 900;
      font-size: 0.8rem;
    }

    .app-container { 
      display: grid; 
      grid-template-columns: 280px 1fr 320px; 
      height: calc(100vh - 80px); 
      gap: 1px; 
      background-color: var(--border-color, #E9ECEF); 
    }
    
    .panel { 
      background-color: var(--bg-card, #FFFFFF); 
      padding: 15px; 
      overflow-y: auto; 
    }
    
    .panel-title { 
      font-weight: bold; 
      margin-bottom: 15px; 
      padding-bottom: 8px; 
      border-bottom: 1px solid var(--color-secondary, #4AA4B9); 
      color: var(--color-primary, #2A5B8C); 
    }
    
    .outline-item { 
      padding: 10px; 
      border-left: 3px solid transparent; 
      cursor: pointer; 
      transition: all 0.2s; 
    }
    
    .outline-item:hover { 
      background-color: var(--bg-primary, #F8F9FA); 
      border-left-color: var(--color-secondary, #4AA4B9); 
    }
    
    .outline-item.active {
      background-color: var(--bg-primary, #F8F9FA);
      border-left-color: var(--color-primary, #2A5B8C);
      font-weight: bold;
    }

    .outline-item.completed {
      color: var(--text-secondary, #666);
    }

    .outline-item.lesson.completed:not(.active) {
      opacity: 0.85;
    }

    .outline-item.module.completed {
      background-color: rgba(58, 127, 92, 0.08);
      border-left-color: var(--color-success, #3A7F5C);
    }
    
    textarea { 
      width: 100%; 
      min-height: 120px; 
      background-color: var(--bg-card, #FFFFFF); 
      color: var(--text-primary, #2C2C2C); 
      border: 1px solid var(--border-color, #E9ECEF); 
      border-radius: 4px; 
      padding: 10px; 
      margin-bottom: 10px; 
      resize: vertical; 
    }
    
    button { 
      background-color: var(--color-primary, #2A5B8C); 
      color: var(--text-inverse, #FFFFFF); 
      border: none; 
      padding: 8px 15px; 
      border-radius: 4px; 
      cursor: pointer; 
      font-weight: bold; 
      transition: background-color 0.2s; 
    }
    
    button:hover { 
      background-color: #1E4567; 
    }
    
    .topbar { 
      display: flex; 
      justify-content: space-between; 
      align-items: center; 
      margin-bottom: 15px; 
      padding-bottom: 10px; 
      border-bottom: 1px solid var(--border-color, #E9ECEF); 
    }
    
    .player-area { 
      background-color: var(--bg-elevated, #FAFBFC); 
      border-radius: 8px; 
      padding: 15px; 
      margin-bottom: 15px; 
    }
    
    .messages-container { 
      height: calc(100vh - 280px); 
      overflow-y: auto; 
      margin-bottom: 15px; 
      padding: 10px; 
      background-color: var(--bg-elevated, #FAFBFC); 
      border-radius: 8px; 
    }
    
    .message { 
      padding: 10px; 
      border-radius: 8px; 
      margin-bottom: 10px; 
      max-width: 90%; 
    }
    
    .message.user { 
      background-color: var(--color-primary, #2A5B8C); 
      color: var(--text-inverse, #FFFFFF);
      margin-left: auto; 
    }
    
    .message.ai { 
      background-color: var(--bg-secondary, #FFFFFF); 
      border: 1px solid var(--border-color, #E9ECEF);
    }
    
    .chat-form {
      display: flex;
      gap: 8px;
      padding: 12px;
      background: rgba(248, 249, 250, 0.5);
      border-top: 1px solid var(--border-color, #E9ECEF);
      border-radius: 0 0 8px 8px;
      margin: 0 -15px -15px -15px; /* Extend to panel edges */
    }

    .chat-form input {
      flex: 1;
      min-width: 0; /* Allow shrinking */
      padding: 10px 16px;
      background-color: var(--bg-card, #FFFFFF);
      color: var(--text-primary, #2C2C2C);
      border: 1px solid var(--border-color, #E9ECEF);
      border-radius: 20px;
      font-size: 0.9rem;
    }

    .chat-form input:focus {
      outline: none;
      border-color: var(--color-secondary, #4AA4B9);
      box-shadow: 0 0 0 2px rgba(74, 164, 185, 0.2);
    }

    .chat-form button[type="submit"] {
      padding: 10px 20px;
      border-radius: 20px;
      background: var(--color-secondary, #4AA4B9);
      color: white;
      border: none;
      cursor: pointer;
      font-weight: 600;
      white-space: nowrap;
      flex-shrink: 0;
      transition: background-color 0.2s, transform 0.1s;
    }

    .chat-form button[type="submit"]:hover {
      background: #3d8fa0;
    }

    .chat-form button[type="submit"]:active {
      transform: scale(0.97);
    }

    /* ========================================
       AI TUTOR CHAT PANEL - Improved Layout
       ======================================== */
    .chat-panel {
      display: flex;
      flex-direction: column;
      height: 100%;
    }

    .chat-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
      flex-shrink: 0;
    }

    .chat-header .panel-title {
      margin: 0;
      padding: 0;
    }

    .chat-stats {
      display: flex;
      gap: 8px;
    }

    .stat-badge {
      display: flex;
      align-items: center;
      gap: 4px;
      padding: 4px 8px;
      background: var(--bg-elevated, #F8F9FA);
      border-radius: 12px;
      font-size: 0.75rem;
      color: var(--text-secondary, #6C757D);
      border: 1px solid var(--border-color, #E9ECEF);
    }

    .stat-badge i {
      font-size: 0.7rem;
      color: var(--color-secondary, #4AA4B9);
    }

    .raise-hand-btn {
      width: 100%;
      background: var(--color-secondary, #4AA4B9);
      color: white;
      border: none;
      border-radius: 8px;
      padding: 10px 16px;
      font-weight: 600;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      margin-bottom: 12px;
      flex-shrink: 0;
      transition: background-color 0.2s, transform 0.1s;
    }

    .raise-hand-btn:hover {
      background: #3d8fa0;
    }

    .raise-hand-btn:active {
      transform: scale(0.98);
    }

    .chat-panel .messages-container {
      flex: 1;
      min-height: 0;
      overflow-y: auto;
      margin-bottom: 0;
      padding: 12px;
      background: var(--bg-elevated, #F8F9FA);
      border-radius: 8px;
      border: 1px solid var(--border-color, #E9ECEF);
    }

    .chat-panel .chat-form {
      margin: 12px 0 0 0;
      padding: 0;
      background: transparent;
      border: none;
      border-radius: 0;
      flex-shrink: 0;
    }

    @media (max-width: 1024px) { 
      .app-container { 
        grid-template-columns: 220px 1fr 280px; 
      } 
    }
    
    @media (max-width: 768px) {
      .app-container {
        grid-template-columns: 1fr;
        grid-template-rows: auto 1fr auto;
        height: auto;
      }
      .panel {
        max-height: 400px;
      }
    }

    /* Toast animations */
    @keyframes toastSlideUp {
      from { transform: translateX(-50%) translateY(100px); opacity: 0; }
      to { transform: translateX(-50%) translateY(0); opacity: 1; }
    }
    @keyframes toastSlideDown {
      from { transform: translateX(-50%) translateY(0); opacity: 1; }
      to { transform: translateX(-50%) translateY(100px); opacity: 0; }
    }

    /* Fallback avatar styling */
    .avatar-static {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      border-radius: 18px;
      color: white;
      font-size: 64px;
    }

    /* Audio-only mode indicator */
    .vh-root.audio-only .avatar-frame {
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
    }
    .vh-root.audio-only .vh-status-badge {
      background: var(--color-secondary, #4AA4B9);
    }

    /* ========================================
       FLOATING AVATAR WIDGET (Picture-in-Picture)
       ======================================== */
    .vh-widget {
      position: fixed;
      top: 100px;
      right: 340px; /* Don't overlap AI Chat sidebar (320px + margin) */
      width: 260px;
      height: auto;
      z-index: 1000;
      border-radius: 12px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.3), 0 2px 8px rgba(0,0,0,0.2);
      background: linear-gradient(135deg, rgba(30,30,50,0.95), rgba(20,20,40,0.98));
      overflow: hidden;
      transition: opacity 0.3s, transform 0.3s;
      border: 1px solid rgba(74, 164, 185, 0.3);
    }
    .vh-widget.is-hidden {
      opacity: 0;
      pointer-events: none;
      transform: scale(0.9);
    }
    .vh-widget:not(.is-hidden) {
      opacity: 1;
      transform: scale(1);
    }
    .vh-widget.minimized {
      height: auto !important;
    }
    .vh-widget.minimized .avatar-frame,
    .vh-widget.minimized .widget-footer {
      display: none;
    }

    /* Widget Header (Drag Handle) */
    .widget-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 12px;
      background: linear-gradient(90deg, var(--color-primary, #2A5B8C), #1E4567);
      cursor: move;
      user-select: none;
    }
    .widget-title {
      color: white;
      font-size: 0.85rem;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .widget-controls {
      display: flex;
      gap: 4px;
    }
    .widget-btn {
      width: 24px;
      height: 24px;
      border: none;
      background: rgba(255,255,255,0.15);
      color: white;
      border-radius: 4px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.75rem;
      transition: background 0.2s;
    }
    .widget-btn:hover {
      background: rgba(255,255,255,0.25);
    }

    /* Widget Avatar Frame */
    .vh-widget .avatar-frame {
      width: 100%;
      height: 200px;
      position: relative;
      background: transparent;
      border-radius: 0;
    }
    .vh-widget .avatar-stage {
      width: 100%;
      height: 100%;
      position: relative;
    }
    .vh-widget #vh-canvas {
      width: 100%;
      height: 100%;
      display: block;
    }
    .vh-widget .avatar-captions {
      position: absolute;
      bottom: 8px;
      left: 8px;
      right: 8px;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 6px 10px;
      border-radius: 6px;
      font-size: 0.75rem;
      text-align: center;
      display: none;
    }
    .vh-widget .avatar-captions:not(:empty) {
      display: block;
    }
    .vh-widget .avatar-live-badge {
      position: absolute;
      top: 8px;
      left: 8px;
      background: #e53935;
      color: white;
      padding: 3px 8px;
      border-radius: 4px;
      font-size: 0.65rem;
      font-weight: bold;
      display: flex;
      align-items: center;
      gap: 4px;
      z-index: 10;
    }
    .vh-widget .live-dot {
      width: 6px;
      height: 6px;
      background: white;
      border-radius: 50%;
      animation: pulse 1.5s infinite;
    }
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    /* Widget Footer */
    .widget-footer {
      padding: 6px 12px;
      background: rgba(0,0,0,0.3);
      text-align: center;
    }
    .widget-footer #vh-status-text {
      color: var(--color-secondary, #4AA4B9);
      font-size: 0.75rem;
    }

    /* Fallback in widget */
    .vh-widget .avatar-static {
      width: 100%;
      height: 200px;
      border-radius: 0;
      font-size: 48px;
    }

    /* Dragging state */
    .vh-widget.dragging {
      opacity: 0.9;
      cursor: grabbing;
    }

    /* Mobile: Bottom-right, smaller */
    @media (max-width: 768px) {
      .vh-widget {
        right: 10px;
        top: auto;
        bottom: 80px;
        width: 180px;
      }
      .vh-widget .avatar-frame {
        height: 140px;
      }
    }
  </style>
</head>
<body>
  <!-- Portal Header -->
  <header class="portal-header">
    <h1><i class="fas fa-chalkboard-teacher"></i> PMERIT Classroom</h1>

    <!-- Proctor Status Indicator (Center) -->
    <div class="proctor-status off" id="proctor-status">
      <span class="status-dot"></span>
      <span class="status-text">Proctor: Off</span>
    </div>

    <nav class="portal-nav">
      <a href="../dashboard.html"><i class="fas fa-home"></i> Dashboard</a>
      <a href="../courses.html"><i class="fas fa-book"></i> Courses</a>
      <span id="user-display">User</span>
    </nav>
  </header>

  <div class="app-container">
    <!-- Left Panel: Outline & Notes -->
    <aside class="panel left-panel">
      <div class="panel-title">Class Outline</div>
      <div id="outline-container"></div>
      
      <div class="panel-title">Notes</div>
      <textarea id="notes-text" placeholder="Write your notes here..."></textarea>
      <button id="save-notes">Save Notes</button>
      
      <div class="panel-title">Resources</div>
      <input type="file" id="file-upload" accept=".pdf,.doc,.docx,.txt,.png,.jpg,.jpeg" multiple style="margin-top: 10px;">
      <div id="resources-container"></div>
    </aside>

    <!-- Center Panel: Content & Avatar with Grid Layout -->
    <main class="panel center-panel">
      <div class="topbar">
        <h2 id="lesson-title">Loading course...</h2>
        <button id="end-class">End Class</button>
      </div>

      <!-- Virtual Human Toggle -->
      <div class="vh-toggle-container">
        <button class="vh-toggle" id="vh-toggle" aria-label="Toggle Virtual Human">
          <span class="sr-only">Virtual Human Mode</span>
        </button>
        <label for="vh-toggle" class="vh-toggle-label">
          <i class="fas fa-robot"></i> Virtual Human Mode
        </label>
      </div>

      <!-- Content Area (lesson content scrolls here) - NOW PRIMARY -->
      <div class="content-area">
        <div class="player-area" id="player-area">
          <!-- Lesson content goes here -->
        </div>

        <!-- Student Controls -->
        <div class="student-controls" style="display: flex; justify-content: center; gap: 10px; margin-top: 15px; flex-wrap: wrap;">
          <button id="prev-lesson-btn" class="control-btn" style="background: var(--bg-elevated); color: var(--text-primary); border: 1px solid var(--border-color);" disabled>
            <i class="fas fa-step-backward"></i> Previous
          </button>
          <button id="pause-lesson-btn" class="control-btn" style="background: var(--bg-elevated); color: var(--text-primary); border: 1px solid var(--border-color);">
            <i class="fas fa-pause"></i> Pause
          </button>
          <button id="bookmark-btn" class="control-btn" style="background: var(--bg-elevated); color: var(--text-primary); border: 1px solid var(--border-color);">
            <i class="fas fa-bookmark"></i> Bookmark
          </button>
          <button id="next-lesson-btn" class="control-btn" style="background: var(--bg-elevated); color: var(--text-primary); border: 1px solid var(--border-color);" disabled>
            <i class="fas fa-step-forward"></i> Next
          </button>
        </div>

        <!-- Progress Bar -->
        <div class="lesson-progress" style="margin-top: 15px;">
          <div style="display: flex; justify-content: space-between; font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 5px;">
            <span>Lesson Progress</span>
            <span id="progress-percent">0%</span>
          </div>
          <div style="height: 8px; background: var(--bg-elevated); border-radius: 4px; overflow: hidden;">
            <div id="progress-bar" style="height: 100%; width: 0%; background: var(--color-secondary); transition: width 0.3s;"></div>
          </div>
        </div>
      </div>
    </main>

    <!-- Right Panel: AI Tutor Chat -->
    <aside class="panel right-panel chat-panel">
      <!-- Header with title and stats badges -->
      <div class="chat-header">
        <div class="panel-title">AI Tutor Chat</div>
        <div class="chat-stats">
          <span class="stat-badge" title="Hand Raises">
            <i class="fas fa-hand-paper"></i>
            <span id="stat-hand-raises">0</span>
          </span>
          <span class="stat-badge" title="Questions Asked">
            <i class="fas fa-question-circle"></i>
            <span id="stat-questions">0</span>
          </span>
        </div>
      </div>

      <!-- Raise Hand Button -->
      <button id="raise-hand-btn" class="raise-hand-btn">
        <i class="fas fa-hand-paper"></i> Raise Hand
      </button>

      <!-- Chat Messages Container -->
      <div class="messages-container" id="chat-messages"></div>

      <!-- Chat Input Form -->
      <form class="chat-form" id="chat-form">
        <input type="text" id="chat-input" placeholder="Ask your AI tutor..." required>
        <button type="submit">Send</button>
      </form>
    </aside>
  </div>

  <!-- FLOATING AVATAR WIDGET (Draggable, Picture-in-Picture style) -->
  <div id="vh-root" class="vh-root vh-widget is-hidden" hidden aria-hidden="true">
    <div class="widget-header" id="widget-drag-handle">
      <span class="widget-title"><i class="fas fa-robot"></i> AI Tutor</span>
      <div class="widget-controls">
        <button class="widget-btn" id="widget-minimize" title="Minimize">
          <i class="fas fa-minus"></i>
        </button>
        <button class="widget-btn" id="widget-close" title="Hide">
          <i class="fas fa-times"></i>
        </button>
      </div>
    </div>
    <div class="avatar-frame tier-standard" id="avatar-frame">
      <div class="avatar-live-badge" id="avatar-live-badge" style="display: none;">
        <span class="live-dot"></span>
        <span>LIVE</span>
      </div>
      <div class="avatar-stage">
        <canvas id="vh-canvas"></canvas>
        <div class="avatar-static" id="avatar-fallback" style="display: none;">
          <i class="fas fa-user-graduate"></i>
        </div>
      </div>
      <div class="avatar-captions" id="vh-captions" aria-live="polite"></div>
    </div>
    <div class="widget-footer">
      <span id="vh-status-text">Ready</span>
    </div>
  </div>

  <script>
    (function () {
      'use strict';

      // Parse courseId and lessonId from URL
      const urlParams = new URLSearchParams(window.location.search);
      const courseId = urlParams.get('courseId') || urlParams.get('course_id');
      const lessonId = urlParams.get('lessonId') || urlParams.get('lesson_id');

      // State management
      const state = {
        courseId: courseId,
        lessonId: lessonId,
        courseData: null,
        currentLesson: null,
        lessonNavigation: null,
        modules: [],
        notes: { content: "", timestamp: null },
        resources: [],
        avatarManager: null,
        gpuStreaming: null,
        sessionStart: Date.now(),
        chatMessages: []
      };

      // Expose state for debugging
      window.classroomState = state;

      // DOM elements
      const dom = {
        lessonTitle: document.getElementById('lesson-title'),
        outlineContainer: document.getElementById('outline-container'),
        notesText: document.getElementById('notes-text'),
        saveNotesBtn: document.getElementById('save-notes'),
        resourcesContainer: document.getElementById('resources-container'),
        fileUpload: document.getElementById('file-upload'),
        endClassBtn: document.getElementById('end-class'),
        chatMessages: document.getElementById('chat-messages'),
        chatForm: document.getElementById('chat-form'),
        chatInput: document.getElementById('chat-input'),
        vhToggle: document.getElementById('vh-toggle'),
        vhContainer: document.getElementById('vh-root'),
        userDisplay: document.getElementById('user-display'),
        playerArea: document.getElementById('player-area'),
        // New controls
        raiseHandBtn: document.getElementById('raise-hand-btn'),
        prevLessonBtn: document.getElementById('prev-lesson-btn'),
        nextLessonBtn: document.getElementById('next-lesson-btn'),
        pauseBtn: document.getElementById('pause-lesson-btn'),
        bookmarkBtn: document.getElementById('bookmark-btn'),
        progressBar: document.getElementById('progress-bar'),
        progressPercent: document.getElementById('progress-percent'),
        statHandRaises: document.getElementById('stat-hand-raises'),
        statQuestions: document.getElementById('stat-questions'),
        // Avatar frame elements (Digital Desk)
        avatarFrame: document.getElementById('avatar-frame'),
        avatarDropZone: document.getElementById('avatar-drop-zone'),
        avatarLiveBadge: document.getElementById('avatar-live-badge'),
        avatarFallback: document.getElementById('avatar-fallback'),
        bandwidthToggle: document.getElementById('bandwidth-toggle'),
        qaRaiseHand: document.getElementById('qa-raise-hand'),
        qaSubmitWork: document.getElementById('qa-submit-work'),
        qaAskHint: document.getElementById('qa-ask-hint'),
        proctorStatus: document.getElementById('proctor-status')
      };

      // Initialize
      async function init() {
        console.log('ðŸŽ“ Initializing classroom for course:', courseId);

        // Validate course ID
        if (!courseId) {
          showError('No course specified. Please select a course from your dashboard.');
          return;
        }

        // Set user display
        const user = window.AUTH?.getCurrentUser();
        if (user) {
          const displayName = user.firstName || user.email?.split('@')[0] || 'Student';
          dom.userDisplay.textContent = displayName;
        }

        // Load saved VH preference, defaulting to true (enabled)
        const savedPreference = localStorage.getItem('pmerit_vh_enabled');
        const vhEnabled = savedPreference === 'false' ? false : true;
        updateVHToggle(vhEnabled);

        bindEvents();

        // Start classroom session via API
        try {
          dom.lessonTitle.textContent = 'Starting session...';
          const session = await window.ClassroomSession.startSession(courseId, lessonId);

          if (session.resumed) {
            addChatMessage('ai', `Welcome back! Resuming your session for "${session.course.title}".`);
          } else {
            addChatMessage('ai', `Welcome to "${session.course.title}"! I'm your AI tutor. Feel free to ask questions anytime.`);
          }

          state.courseData = session.course;
          dom.lessonTitle.textContent = session.course.title;

          // Load course modules and lessons
          await loadCourseModules();

        } catch (error) {
          console.error('Failed to start session:', error);
          // Fallback to demo mode
          addChatMessage('ai', 'Hello! I\'m your AI tutor. How can I help you today?');
          await loadCourseDataFallback();
        }

        loadUserNotes();
        renderOutline();

        // Initialize avatar manager
        await initAvatarManager(vhEnabled);

        // Initialize GPU Streaming for tiered avatar (Phase 4)
        state.gpuStreaming = await initGPUStreaming();

        console.log('âœ… Classroom initialized');
        console.log('ðŸŽ® Digital Desk modules loaded: ProctorController, VisionAI, GPUStreaming');
      }

      // Show error message
      function showError(message) {
        dom.lessonTitle.textContent = 'Error';
        dom.playerArea.innerHTML = `
          <div style="text-align: center; padding: 40px; color: var(--color-error, #C4314B);">
            <i class="fas fa-exclamation-circle" style="font-size: 48px; margin-bottom: 16px;"></i>
            <p>${message}</p>
            <a href="../dashboard.html" class="btn" style="margin-top: 20px;">
              <i class="fas fa-home"></i> Return to Dashboard
            </a>
          </div>
        `;
      }

      // Load course modules from API
      async function loadCourseModules() {
        try {
          const modules = await window.ClassroomSession.getCourseModules(courseId);
          state.modules = modules;
          renderOutline();

          // Load first lesson if no specific lesson requested
          if (!lessonId && modules.length > 0 && modules[0].lessons?.length > 0) {
            const firstLesson = modules[0].lessons[0];
            await loadLesson(firstLesson.lesson_id);
          } else if (lessonId) {
            await loadLesson(lessonId);
          }
        } catch (error) {
          console.error('Failed to load modules:', error);
        }
      }

      // Load lesson content
      async function loadLesson(lessonId) {
        try {
          const data = await window.ClassroomSession.getLessonDetails(lessonId);
          state.currentLesson = data.lesson;
          state.lessonId = lessonId;

          // Update UI
          dom.lessonTitle.textContent = `${state.courseData?.title || 'Course'} - ${data.lesson.title}`;

          // Render lesson content
          renderLessonContent(data.lesson);

          // Update navigation buttons
          updateNavigation(data.navigation);

          // Update session with current lesson
          await window.ClassroomSession.updateProgress({
            lesson_id: lessonId
          });

          // Reset progress bar for new lesson
          updateProgressBar(0);

          // Update outline to show active lesson
          renderOutline();

          // Update stats
          updateStats();

        } catch (error) {
          console.error('Failed to load lesson:', error);
        }
      }

      // Render lesson content in player area
      function renderLessonContent(lesson) {
        const typeIcon = {
          video: 'fa-play-circle',
          reading: 'fa-book-open',
          interactive: 'fa-hand-pointer',
          quiz: 'fa-question-circle',
          project: 'fa-project-diagram',
          discussion: 'fa-comments'
        };

        const icon = typeIcon[lesson.lesson_type] || 'fa-file';
        const duration = lesson.estimated_duration_minutes
          ? `${lesson.estimated_duration_minutes} min`
          : '';

        let contentHTML = `
          <div class="lesson-header" style="margin-bottom: 20px;">
            <h3><i class="fas ${icon}"></i> ${lesson.title}</h3>
            <div class="lesson-meta" style="color: var(--text-secondary); font-size: 0.9rem; margin-top: 8px;">
              <span><i class="fas fa-clock"></i> ${duration}</span>
              <span style="margin-left: 16px;"><i class="fas fa-layer-group"></i> ${lesson.module_title || 'Module'}</span>
            </div>
          </div>
        `;

        // Render based on lesson type
        if (lesson.lesson_type === 'video' && lesson.content_url) {
          contentHTML += `
            <div class="video-container" style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; border-radius: 8px;">
              <iframe src="${lesson.content_url}" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border: none;" allowfullscreen></iframe>
            </div>
          `;
        } else if (lesson.transcript) {
          contentHTML += `
            <div class="lesson-content" style="background: var(--bg-elevated); padding: 20px; border-radius: 8px; max-height: 400px; overflow-y: auto;">
              ${lesson.transcript}
            </div>
          `;
        } else {
          contentHTML += `
            <div class="lesson-placeholder" style="text-align: center; padding: 60px; background: var(--bg-elevated); border-radius: 8px;">
              <i class="fas ${icon}" style="font-size: 64px; color: var(--color-secondary); margin-bottom: 16px;"></i>
              <p>Lesson content is being prepared.</p>
              <p style="color: var(--text-secondary); margin-top: 8px;">Use the AI tutor chat to ask questions about this topic.</p>
            </div>
          `;
        }

        dom.playerArea.innerHTML = contentHTML;
      }

      // Fallback to demo data if API fails
      async function loadCourseDataFallback() {
        const demoData = {
          id: courseId || 'demo-course',
          title: "Introduction to PMERIT Classroom",
          modules: [
            {
              id: 'mod-1',
              title: "Module 1: Getting Started",
              lessons: [
                { lesson_id: 'les-1', title: "Welcome to PMERIT", lesson_type: "video", estimated_duration_minutes: 3 },
                { lesson_id: 'les-2', title: "How to Use This Platform", lesson_type: "video", estimated_duration_minutes: 5 }
              ]
            },
            {
              id: 'mod-2',
              title: "Module 2: Core Concepts",
              lessons: [
                { lesson_id: 'les-3', title: "Basic Principles", lesson_type: "video", estimated_duration_minutes: 7 },
                { lesson_id: 'les-4', title: "Advanced Techniques", lesson_type: "reading", estimated_duration_minutes: 10 }
              ]
            }
          ]
        };

        state.courseData = demoData;
        state.modules = demoData.modules;
        dom.lessonTitle.textContent = demoData.title;
      }

      // Initialize Avatar Manager
      // NOTE: In classroom, GPUStreaming handles WebGL rendering.
      // AvatarManager is only used for TTS/audio, NOT for canvas rendering.
      async function initAvatarManager(enabled) {
        try {
          if (!window.AvatarManager) {
            console.warn('AvatarManager not loaded - using GPUStreaming only');
            updateVHStatus('Virtual Human is ready');
            return;
          }

          // Create AvatarManager but DISABLE its WebGL provider
          // (GPUStreaming handles all canvas rendering)
          state.avatarManager = new window.AvatarManager({
            canvasId: null, // Don't use canvas - GPUStreaming handles it
            captionsId: 'vh-captions',
            enabled: false, // Disable WebGL provider
            apiBaseUrl: window.CONFIG?.API_BASE_URL || 'https://pmerit-api-worker.peoplemerit.workers.dev',
            onSpeakStart: () => {
              dom.vhContainer.classList.add('speaking');
              dom.avatarFrame?.classList.add('speaking');
            },
            onSpeakEnd: () => {
              dom.vhContainer.classList.remove('speaking');
              dom.avatarFrame?.classList.remove('speaking');
            },
            onError: null
          });

          // Initialize for TTS only (no WebGL)
          await state.avatarManager.init();
          console.log('AvatarManager initialized for TTS only (GPUStreaming handles rendering)');

          if (enabled) {
            updateVHStatus('Virtual Human is ready');
            const userTier = getUserTier();
            setAvatarTier(userTier);
          } else {
            dom.vhContainer.classList.add('audio-only');
            setAvatarTier('fallback');
            updateVHStatus('Virtual Human disabled');
          }
        } catch (error) {
          console.warn('Avatar init graceful fallback:', error.message);
          updateVHStatus('Ready (basic mode)');
        }
      }

      // Helper to update VH status text
      function updateVHStatus(text) {
        const statusText = document.getElementById('vh-status-text');
        if (statusText) {
          statusText.textContent = text;
        }
      }

      // Get user subscription tier
      function getUserTier() {
        // Check user subscription from localStorage or API
        const user = window.AUTH?.getCurrentUser();
        const tier = user?.subscription_tier || localStorage.getItem('pmerit_user_tier') || 'standard';
        return tier; // 'premium', 'standard', 'free', or 'fallback'
      }

      // =========================================
      // DIGITAL DESK MODULES (Phase 2-4)
      // =========================================

      // Initialize GPU Streaming for tiered avatar rendering
      async function initGPUStreaming() {
        if (!window.GPUStreaming) {
          console.warn('GPUStreaming module not loaded - using fallback');
          showAvatarError({ message: 'WebGL not available' });
          return null;
        }

        try {
          const gpuStreaming = await window.createGPUStreaming(dom.avatarFrame, {
            idleTimeout: 300000, // 5 minutes
            maxSessionDuration: 3600000 // 1 hour
          });

          // Listen for tier changes
          gpuStreaming.onTierChange((newTier, previousTier) => {
            console.log(`Avatar tier changed: ${previousTier} -> ${newTier}`);
            setAvatarTier(newTier);
          });

          // Listen for connection changes
          gpuStreaming.onConnectionChange((isConnected) => {
            if (isConnected) {
              console.log('GPU streaming connected');
            } else {
              console.log('GPU streaming disconnected');
            }
          });

          // Listen for cost updates
          gpuStreaming.onCostUpdate((costCents) => {
            console.log(`Session cost: $${(costCents / 100).toFixed(2)}`);
          });

          // Listen for errors - SILENT FALLBACK
          gpuStreaming.onError((type, message) => {
            console.warn(`GPU streaming error (${type}):`, message);
            // Silent fallback - no scary error screens
            showAvatarError({ message });
          });

          // Start streaming to load the avatar
          // Check if VH is enabled before starting
          const vhEnabled = localStorage.getItem('pmerit_vh_enabled') !== 'false';
          if (vhEnabled) {
            console.log('ðŸŽ¬ Starting avatar streaming...');
            await gpuStreaming.startStreaming();
            updateVHStatus('Ready');
          }

          return gpuStreaming;
        } catch (error) {
          console.error('Failed to initialize GPU streaming:', error);
          // Silent fallback
          showAvatarError(error);
          return null;
        }
      }

      // Initialize Vision AI for proctored exams
      async function initVisionAI() {
        if (!window.VisionAI) {
          console.warn('VisionAI module not loaded');
          return null;
        }

        // Only initialize when entering an exam
        return null; // Will be initialized on-demand
      }

      // Start a proctored exam session
      async function startProctoredExam(examData) {
        if (!window.ProctorController) {
          console.error('ProctorController module not loaded');
          return false;
        }

        try {
          // Create proctor session
          const proctor = await window.createProctorSession(examData, {
            maxViolations: 3,
            enableVisionAI: true,
            timerWarningMinutes: 5,
            timerCriticalMinutes: 1,
            onViolation: (violation) => {
              console.warn('Proctor violation:', violation);
            },
            onExamEnd: (result) => {
              console.log('Exam ended:', result);
              endProctoredExam();
            }
          });

          // Initialize Vision AI if enabled
          if (examData.enableVisionAI !== false) {
            const visionAI = await window.createVisionAI('vision-ai-video', {
              faceDetectionInterval: 1000,
              gazeThreshold: 0.3,
              confidenceThreshold: 0.7
            });

            if (visionAI) {
              // Connect Vision AI to Proctor Controller
              proctor.setVisionAI(visionAI);

              // Start detection
              await visionAI.startDetection();
            }
          }

          // Enter proctor mode
          proctor.enterProctorMode();

          return proctor;

        } catch (error) {
          console.error('Failed to start proctored exam:', error);
          return false;
        }
      }

      // End proctored exam
      async function endProctoredExam() {
        if (window.proctorController) {
          // Vision AI cleanup
          if (window.proctorController.visionAI) {
            window.proctorController.visionAI.destroy();
          }

          // Exit proctor mode
          window.proctorController.exitProctorMode();
        }
      }

      // Expose functions globally for testing
      window.startProctoredExam = startProctoredExam;
      window.endProctoredExam = endProctoredExam;

      // Set avatar tier styling
      function setAvatarTier(tier) {
        if (!dom.avatarFrame) return;

        // Remove all tier classes
        dom.avatarFrame.classList.remove('tier-free', 'tier-standard', 'tier-premium', 'tier-fallback');

        // Add new tier class
        dom.avatarFrame.classList.add(`tier-${tier}`);

        // Update live badge
        if (dom.avatarLiveBadge) {
          if (tier === 'premium') {
            dom.avatarLiveBadge.innerHTML = '<span class="live-dot"></span> LIVE HD';
            dom.avatarLiveBadge.classList.add('premium', 'hd');
            dom.avatarLiveBadge.style.display = 'flex';
          } else if (tier === 'standard') {
            dom.avatarLiveBadge.innerHTML = '<span class="live-dot"></span> LIVE';
            dom.avatarLiveBadge.classList.remove('premium', 'hd');
            dom.avatarLiveBadge.style.display = 'flex';
          } else {
            dom.avatarLiveBadge.style.display = 'none';
          }
        }

        // Update fallback visibility
        if (dom.avatarFallback) {
          dom.avatarFallback.style.display = tier === 'fallback' ? 'flex' : 'none';
        }

        console.log(`Avatar tier set to: ${tier}`);
      }

      // Bind event handlers
      function bindEvents() {
        dom.saveNotesBtn.addEventListener('click', saveNotes);
        dom.fileUpload.addEventListener('change', handleFileUpload);
        dom.endClassBtn.addEventListener('click', endClass);
        dom.chatForm.addEventListener('submit', handleChatSubmit);
        dom.vhToggle.addEventListener('click', toggleVirtualHuman);

        // New control handlers
        dom.raiseHandBtn.addEventListener('click', handleRaiseHand);
        dom.prevLessonBtn.addEventListener('click', handlePrevLesson);
        dom.nextLessonBtn.addEventListener('click', handleNextLesson);
        dom.pauseBtn.addEventListener('click', handlePauseResume);
        dom.bookmarkBtn.addEventListener('click', handleBookmark);

        // Widget controls
        setupWidgetControls();
      }

      // =========================================
      // FLOATING WIDGET CONTROLS
      // =========================================
      function setupWidgetControls() {
        const widget = document.getElementById('vh-root');
        const dragHandle = document.getElementById('widget-drag-handle');
        const minimizeBtn = document.getElementById('widget-minimize');
        const closeBtn = document.getElementById('widget-close');

        if (!widget || !dragHandle) return;

        // Make widget draggable
        let isDragging = false;
        let startX, startY, startLeft, startTop;

        dragHandle.addEventListener('mousedown', (e) => {
          if (e.target.closest('.widget-btn')) return; // Don't drag when clicking buttons
          isDragging = true;
          widget.classList.add('dragging');
          startX = e.clientX;
          startY = e.clientY;
          const rect = widget.getBoundingClientRect();
          startLeft = rect.left;
          startTop = rect.top;
          e.preventDefault();
        });

        document.addEventListener('mousemove', (e) => {
          if (!isDragging) return;
          const dx = e.clientX - startX;
          const dy = e.clientY - startY;

          // Calculate new position
          let newLeft = startLeft + dx;
          let newTop = startTop + dy;

          // Keep within viewport
          const maxLeft = window.innerWidth - widget.offsetWidth - 10;
          const maxTop = window.innerHeight - widget.offsetHeight - 10;
          newLeft = Math.max(10, Math.min(newLeft, maxLeft));
          newTop = Math.max(10, Math.min(newTop, maxTop));

          widget.style.left = newLeft + 'px';
          widget.style.top = newTop + 'px';
          widget.style.right = 'auto'; // Override CSS right positioning
        });

        document.addEventListener('mouseup', () => {
          if (isDragging) {
            isDragging = false;
            widget.classList.remove('dragging');
            // Save position to localStorage
            localStorage.setItem('pmerit_widget_pos', JSON.stringify({
              left: widget.style.left,
              top: widget.style.top
            }));
          }
        });

        // Touch support for mobile
        dragHandle.addEventListener('touchstart', (e) => {
          if (e.target.closest('.widget-btn')) return;
          const touch = e.touches[0];
          isDragging = true;
          startX = touch.clientX;
          startY = touch.clientY;
          const rect = widget.getBoundingClientRect();
          startLeft = rect.left;
          startTop = rect.top;
        }, { passive: true });

        document.addEventListener('touchmove', (e) => {
          if (!isDragging) return;
          const touch = e.touches[0];
          const dx = touch.clientX - startX;
          const dy = touch.clientY - startY;
          let newLeft = startLeft + dx;
          let newTop = startTop + dy;
          const maxLeft = window.innerWidth - widget.offsetWidth - 10;
          const maxTop = window.innerHeight - widget.offsetHeight - 10;
          newLeft = Math.max(10, Math.min(newLeft, maxLeft));
          newTop = Math.max(10, Math.min(newTop, maxTop));
          widget.style.left = newLeft + 'px';
          widget.style.top = newTop + 'px';
          widget.style.right = 'auto';
        }, { passive: true });

        document.addEventListener('touchend', () => {
          isDragging = false;
        });

        // Restore saved position
        const savedPos = localStorage.getItem('pmerit_widget_pos');
        if (savedPos) {
          try {
            const pos = JSON.parse(savedPos);
            widget.style.left = pos.left;
            widget.style.top = pos.top;
            widget.style.right = 'auto';
          } catch (e) { /* ignore */ }
        }

        // Minimize button
        if (minimizeBtn) {
          minimizeBtn.addEventListener('click', () => {
            widget.classList.toggle('minimized');
            const icon = minimizeBtn.querySelector('i');
            if (widget.classList.contains('minimized')) {
              icon.className = 'fas fa-plus';
              minimizeBtn.title = 'Expand';
            } else {
              icon.className = 'fas fa-minus';
              minimizeBtn.title = 'Minimize';
            }
          });
        }

        // Close button (hides widget, toggles VH off)
        if (closeBtn) {
          closeBtn.addEventListener('click', () => {
            toggleVirtualHuman(); // This will hide the widget
          });
        }
      }

      // Handle Raise Hand button
      async function handleRaiseHand() {
        // Focus chat input for question
        dom.chatInput.focus();
        dom.chatInput.placeholder = 'Type your question here...';

        // Visual feedback
        dom.raiseHandBtn.innerHTML = '<i class="fas fa-hand-paper"></i> Hand Raised!';
        dom.raiseHandBtn.style.background = 'var(--color-success, #3A7F5C)';

        // Log interaction
        if (window.ClassroomSession?.hasActiveSession()) {
          await window.ClassroomSession.logInteraction('hand_raise', {
            position: { lessonId: state.lessonId }
          });
          updateStats();
        }

        // Reset button after 3 seconds
        setTimeout(() => {
          dom.raiseHandBtn.innerHTML = '<i class="fas fa-hand-paper"></i> Raise Hand';
          dom.raiseHandBtn.style.background = 'var(--color-secondary, #4AA4B9)';
          dom.chatInput.placeholder = 'Ask your AI tutor...';
        }, 3000);
      }

      // Handle Previous Lesson
      async function handlePrevLesson() {
        if (state.lessonNavigation?.prev_lesson_id) {
          await loadLesson(state.lessonNavigation.prev_lesson_id);
        }
      }

      // Handle Next Lesson
      async function handleNextLesson() {
        if (state.lessonNavigation?.next_lesson_id) {
          // Mark current lesson as completed before moving to next
          if (state.lessonId) {
            markLessonCompleted(state.lessonId);
          }
          await loadLesson(state.lessonNavigation.next_lesson_id);
        }
      }

      // Handle Pause/Resume
      let isPaused = false;
      function handlePauseResume() {
        isPaused = !isPaused;

        if (isPaused) {
          dom.pauseBtn.innerHTML = '<i class="fas fa-play"></i> Resume';
          // Log pause
          if (window.ClassroomSession?.hasActiveSession()) {
            window.ClassroomSession.logInteraction('pause', {
              position: { lessonId: state.lessonId }
            });
          }
        } else {
          dom.pauseBtn.innerHTML = '<i class="fas fa-pause"></i> Pause';
          // Log resume
          if (window.ClassroomSession?.hasActiveSession()) {
            window.ClassroomSession.logInteraction('resume', {
              position: { lessonId: state.lessonId }
            });
          }
        }
      }

      // Handle Bookmark
      async function handleBookmark() {
        // Save bookmark
        const bookmarks = JSON.parse(localStorage.getItem(`pmerit_bookmarks_${courseId}`) || '[]');
        const bookmark = {
          lessonId: state.lessonId,
          lessonTitle: state.currentLesson?.title,
          timestamp: new Date().toISOString()
        };
        bookmarks.push(bookmark);
        localStorage.setItem(`pmerit_bookmarks_${courseId}`, JSON.stringify(bookmarks));

        // Log interaction
        if (window.ClassroomSession?.hasActiveSession()) {
          await window.ClassroomSession.logInteraction('bookmark', {
            position: { lessonId: state.lessonId }
          });
        }

        // Visual feedback
        dom.bookmarkBtn.innerHTML = '<i class="fas fa-bookmark"></i> Saved!';
        dom.bookmarkBtn.style.color = 'var(--color-success, #3A7F5C)';
        setTimeout(() => {
          dom.bookmarkBtn.innerHTML = '<i class="fas fa-bookmark"></i> Bookmark';
          dom.bookmarkBtn.style.color = '';
        }, 2000);
      }

      // Update session stats display
      function updateStats() {
        const sessionState = window.ClassroomSession?.getState() || {};
        dom.statHandRaises.textContent = sessionState.handRaises || 0;
        dom.statQuestions.textContent = sessionState.questionsAsked || 0;
      }

      // Update progress bar
      function updateProgressBar(percent) {
        dom.progressBar.style.width = `${percent}%`;
        dom.progressPercent.textContent = `${Math.round(percent)}%`;
      }

      // Update navigation buttons
      function updateNavigation(navigation) {
        state.lessonNavigation = navigation;
        dom.prevLessonBtn.disabled = !navigation?.prev_lesson_id;
        dom.nextLessonBtn.disabled = !navigation?.next_lesson_id;
      }

      // Toggle Virtual Human
      async function toggleVirtualHuman() {
        const currentlyEnabled = !dom.vhToggle.classList.contains('off');
        const newState = !currentlyEnabled;

        console.log('VH Toggle:', currentlyEnabled, '->', newState);

        updateVHToggle(newState);
        localStorage.setItem('pmerit_vh_enabled', newState.toString());

        if (state.avatarManager) {
          state.avatarManager.setEnabled(newState);
        }

        if (newState) {
          // Turning ON - show VH and initialize if needed
          dom.vhContainer.classList.remove('audio-only');
          updateVHStatus('Initializing...');

          // Initialize avatar manager if not already done
          if (state.avatarManager && !state.avatarManager.state?.initialized) {
            initAvatarManager(true);
          } else if (!state.avatarManager) {
            initAvatarManager(true);
          } else {
            // Already initialized - just update status
            if (state.avatarManager.state?.provider) {
              updateVHStatus('Virtual Human is ready');
            } else {
              updateVHStatus('Ready (audio mode)');
            }
          }

          // Also init/start GPU streaming if available
          if (window.GPUStreaming) {
            if (!state.gpuStreaming) {
              state.gpuStreaming = await initGPUStreaming();
            } else {
              // GPUStreaming exists but may not be streaming
              console.log('ðŸŽ¬ Starting avatar streaming...');
              await state.gpuStreaming.startStreaming();
              updateVHStatus('Virtual Human is ready');
            }
          }
        } else {
          // Turning OFF - hide VH and stop streaming
          dom.vhContainer.classList.add('audio-only');
          updateVHStatus('Virtual Human disabled');
          if (state.gpuStreaming) {
            state.gpuStreaming.stopStreaming();
          }
        }
      }

      // Update VH toggle UI
      function updateVHToggle(enabled) {
        if (enabled) {
          dom.vhToggle.classList.remove('off');
          // Show vh-root container
          dom.vhContainer.classList.remove('is-hidden');
          dom.vhContainer.removeAttribute('hidden');
          dom.vhContainer.setAttribute('aria-hidden', 'false');
        } else {
          dom.vhToggle.classList.add('off');
          // Hide vh-root container
          dom.vhContainer.classList.add('is-hidden');
          dom.vhContainer.setAttribute('hidden', '');
          dom.vhContainer.setAttribute('aria-hidden', 'true');
        }
      }

      // Load user notes
      function loadUserNotes() {
        const noteKey = `pmerit_notes_${courseId}`;
        const savedNotes = localStorage.getItem(noteKey);
        if (savedNotes) {
          state.notes = JSON.parse(savedNotes);
          dom.notesText.value = state.notes.content || "";
        }
      }

      // Render course outline with completion indicators
      function renderOutline() {
        if (!state.modules || state.modules.length === 0) {
          dom.outlineContainer.innerHTML = '<p style="color: var(--text-secondary);">No modules available.</p>';
          return;
        }

        // Get completed lessons from localStorage
        const completedLessons = JSON.parse(localStorage.getItem(`pmerit_completed_${state.courseId}`) || '[]');

        let outlineHTML = '';
        state.modules.forEach((module, moduleIndex) => {
          // Count completed lessons in this module
          const moduleLessons = module.lessons || [];
          const completedInModule = moduleLessons.filter(l => completedLessons.includes(l.lesson_id)).length;
          const moduleComplete = moduleLessons.length > 0 && completedInModule === moduleLessons.length;
          const moduleProgress = moduleLessons.length > 0 ? Math.round((completedInModule / moduleLessons.length) * 100) : 0;

          outlineHTML += `
            <div class="outline-item module ${moduleComplete ? 'completed' : ''}" style="display: flex; align-items: center; justify-content: space-between;">
              <span><i class="fas ${moduleComplete ? 'fa-folder-open' : 'fa-folder'}"></i> ${module.title}</span>
              ${moduleProgress > 0 ? `<span class="module-progress" style="font-size: 0.75rem; color: var(--color-secondary); margin-left: 8px;">${moduleProgress}%</span>` : ''}
            </div>`;
          if (module.lessons && module.lessons.length > 0) {
            module.lessons.forEach((lesson) => {
              const isActive = state.lessonId === lesson.lesson_id;
              const isCompleted = completedLessons.includes(lesson.lesson_id);
              const icon = isCompleted ? 'fa-check-circle' :
                          lesson.lesson_type === 'video' ? 'fa-play-circle' :
                          lesson.lesson_type === 'reading' ? 'fa-book' : 'fa-file';
              const iconColor = isCompleted ? 'color: var(--color-success, #3A7F5C);' : '';
              const duration = lesson.estimated_duration_minutes ? `${lesson.estimated_duration_minutes}m` : '';
              outlineHTML += `
                <div class="outline-item lesson ${isActive ? 'active' : ''} ${isCompleted ? 'completed' : ''}"
                     style="padding-left: 25px; display: flex; align-items: center; gap: 8px;"
                     data-lesson-id="${lesson.lesson_id}"
                     onclick="window.loadLesson('${lesson.lesson_id}')">
                  <i class="fas ${icon}" style="${iconColor}"></i>
                  <span style="flex: 1;">${lesson.title || lesson.lesson_title}</span>
                  ${duration ? `<small style="color: var(--text-secondary);">(${duration})</small>` : ''}
                </div>
              `;
            });
          }
        });
        dom.outlineContainer.innerHTML = outlineHTML;
      }

      // Mark lesson as completed
      function markLessonCompleted(lessonId) {
        const completedLessons = JSON.parse(localStorage.getItem(`pmerit_completed_${state.courseId}`) || '[]');
        if (!completedLessons.includes(lessonId)) {
          completedLessons.push(lessonId);
          localStorage.setItem(`pmerit_completed_${state.courseId}`, JSON.stringify(completedLessons));
          renderOutline(); // Re-render to show checkmark
        }
      }

      // Expose for testing
      window.markLessonCompleted = markLessonCompleted;

      // Expose loadLesson globally for outline clicks
      window.loadLesson = async function(lessonId) {
        await loadLesson(lessonId);
      };

      // Save notes
      function saveNotes() {
        state.notes.content = dom.notesText.value;
        state.notes.timestamp = new Date().toISOString();
        localStorage.setItem(`pmerit_notes_${courseId}`, JSON.stringify(state.notes));

        // Log interaction
        if (window.ClassroomSession?.hasActiveSession()) {
          window.ClassroomSession.logInteraction('note', {
            position: { lessonId: state.lessonId }
          });
        }

        // Show success feedback
        const btn = dom.saveNotesBtn;
        const originalText = btn.textContent;
        btn.textContent = 'âœ“ Saved!';
        btn.style.backgroundColor = 'var(--color-success, #3A7F5C)';
        setTimeout(() => {
          btn.textContent = originalText;
          btn.style.backgroundColor = '';
        }, 2000);
      }

      // Handle file upload
      function handleFileUpload(event) {
        const files = Array.from(event.target.files);
        files.forEach(file => {
          state.resources.push({ name: file.name, size: file.size, type: file.type });
        });
        renderResources();
      }

      // Render resources
      function renderResources() {
        let resourcesHTML = '';
        state.resources.forEach(resource => {
          resourcesHTML += `<div class="resource-item"><strong>${resource.name}</strong> <small>(${formatFileSize(resource.size)})</small></div>`;
        });
        dom.resourcesContainer.innerHTML = resourcesHTML || '<p>No resources uploaded yet.</p>';
      }

      // Format file size
      function formatFileSize(bytes) {
        if (bytes < 1024) return bytes + ' bytes';
        else if (bytes < 1048576) return (bytes / 1024).toFixed(1) + ' KB';
        else return (bytes / 1048576).toFixed(1) + ' MB';
      }

      // Handle chat submit - uses real AI API
      async function handleChatSubmit(event) {
        event.preventDefault();
        const message = dom.chatInput.value.trim();
        if (!message) return;

        addChatMessage('user', message);
        dom.chatInput.value = '';

        // Log hand raise interaction
        const startTime = Date.now();
        if (window.ClassroomSession?.hasActiveSession()) {
          await window.ClassroomSession.raiseHand(message);
        }

        // Call AI Tutor API
        try {
          const response = await fetch(`${window.CONFIG?.API_BASE_URL || 'https://pmerit-api-worker.peoplemerit.workers.dev'}/api/v1/ai/tutor`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              messages: state.chatMessages.concat([{ role: 'user', content: message }])
            })
          });

          // Handle streaming response
          const reader = response.body.getReader();
          const decoder = new TextDecoder();
          let aiResponse = '';

          while (true) {
            const { done, value } = await reader.read();
            if (done) break;

            const chunk = decoder.decode(value, { stream: true });
            // Parse SSE data
            const lines = chunk.split('\n');
            for (const line of lines) {
              if (line.startsWith('data: ')) {
                try {
                  const data = JSON.parse(line.slice(6));
                  if (data.response) {
                    aiResponse += data.response;
                  }
                } catch (e) {
                  // Not JSON, might be raw text
                  aiResponse += line.slice(6);
                }
              }
            }
          }

          // Clean up response
          aiResponse = aiResponse.trim() || "I'm here to help! Could you please rephrase your question?";

          // Log response time
          const responseTime = Date.now() - startTime;
          if (window.ClassroomSession?.hasActiveSession()) {
            await window.ClassroomSession.logInteraction('question', {
              question: message,
              response: aiResponse,
              responseTimeMs: responseTime
            });
          }

          // Update chat history
          state.chatMessages.push({ role: 'user', content: message });
          state.chatMessages.push({ role: 'assistant', content: aiResponse });

          addChatMessage('ai', aiResponse);

          // Speak with avatar if enabled
          if (state.avatarManager?.isEnabled()) {
            await state.avatarManager.speak(aiResponse);
          }

        } catch (error) {
          console.error('AI chat error:', error);
          addChatMessage('ai', 'I apologize, but I encountered an issue. Please try again.');
        }
      }

      // Add chat message
      function addChatMessage(sender, message) {
        const messageDiv = document.createElement('div');
        messageDiv.classList.add('message', sender);
        messageDiv.textContent = message;
        dom.chatMessages.appendChild(messageDiv);
        dom.chatMessages.scrollTop = dom.chatMessages.scrollHeight;
      }

      // Show avatar error - GRACEFUL FALLBACK (no red error screens)
      function showAvatarError(error) {
        console.warn('Avatar fallback triggered:', error?.message || error);

        // Don't destroy the container - just switch to fallback mode
        // Show static fallback avatar instead of error
        if (dom.avatarFallback) {
          dom.avatarFallback.style.display = 'flex';
        }

        // Hide the canvas (if it exists)
        const canvas = document.getElementById('vh-canvas');
        if (canvas) {
          canvas.style.display = 'none';
        }

        // Update status text with friendly message (not scary error)
        const statusText = document.getElementById('vh-status-text');
        if (statusText) {
          statusText.textContent = 'Audio-only mode active';
        }

        // Set fallback tier
        setAvatarTier('fallback');

        // Add audio-only class but keep container visible
        dom.vhContainer.classList.add('audio-only');

        // Show non-intrusive toast notification instead of blocking error
        showToast('Low bandwidth detected. Using audio-only mode.', 'info');
      }

      // Toast notification helper
      function showToast(message, type = 'info') {
        // Remove existing toast if any
        const existingToast = document.querySelector('.pmerit-toast');
        if (existingToast) {
          existingToast.remove();
        }

        const toast = document.createElement('div');
        toast.className = `pmerit-toast pmerit-toast-${type}`;
        toast.style.cssText = `
          position: fixed;
          bottom: 20px;
          left: 50%;
          transform: translateX(-50%);
          background: ${type === 'info' ? 'var(--color-secondary, #4AA4B9)' : 'var(--color-warning, #E5A139)'};
          color: white;
          padding: 12px 24px;
          border-radius: 8px;
          font-size: 0.9rem;
          z-index: 10000;
          box-shadow: 0 4px 12px rgba(0,0,0,0.2);
          animation: toastSlideUp 0.3s ease-out;
        `;
        toast.innerHTML = `<i class="fas fa-info-circle"></i> ${message}`;
        document.body.appendChild(toast);

        // Auto-remove after 4 seconds
        setTimeout(() => {
          toast.style.animation = 'toastSlideDown 0.3s ease-in forwards';
          setTimeout(() => toast.remove(), 300);
        }, 4000);
      }

      // End class session
      async function endClass() {
        if (!confirm('Are you sure you want to end this class session?')) {
          return;
        }

        try {
          // End session via API
          if (window.ClassroomSession?.hasActiveSession()) {
            const notes = dom.notesText.value;
            await window.ClassroomSession.endSession(notes);
          }
        } catch (error) {
          console.error('Failed to end session:', error);
        }

        // Clean up avatar
        if (state.avatarManager) {
          state.avatarManager.dispose();
        }

        // Redirect to dashboard
        window.location.href = '../dashboard.html';
      }

      // Start initialization
      document.addEventListener('DOMContentLoaded', init);
    })();
  </script>
</body>
</html>
